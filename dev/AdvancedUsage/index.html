<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Advanced Usage · Fortuna.jl</title><meta name="title" content="Advanced Usage · Fortuna.jl"/><meta property="og:title" content="Advanced Usage · Fortuna.jl"/><meta property="twitter:title" content="Advanced Usage · Fortuna.jl"/><meta name="description" content="Documentation for Fortuna.jl."/><meta property="og:description" content="Documentation for Fortuna.jl."/><meta property="twitter:description" content="Documentation for Fortuna.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/Favicon.ico" rel="icon" type="image/x-icon"/><link href="../assets/Custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="Fortuna.jl logo"/></a><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Random Variables</span><ul><li><a class="tocitem" href="../Random Variables/DefineRandomVariables/">Defining Random Variables</a></li><li><a class="tocitem" href="../Random Variables/SampleRandomVariables/">Sampling Random Variables</a></li></ul></li><li><span class="tocitem">Isoprobabilistic Transformations</span><ul><li><a class="tocitem" href="../Isoprobabilistic Transformations/NatafTransformation/">Nataf Transformation</a></li><li><a class="tocitem" href="../Isoprobabilistic Transformations/RosenblattTransformation/">Rosenblatt Transformation</a></li></ul></li><li><span class="tocitem">Reliability Problems</span><ul><li><a class="tocitem" href="../Reliability Problems/ReliabilityProblems/">Reliability Problems</a></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Monte Carlo Methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../Reliability Problems/MC/">Direct Monte Carlo Simulations</a></li><li><a class="tocitem" href="../Reliability Problems/IS/">Importance Sampling</a></li></ul></li><li><a class="tocitem" href="../Reliability Problems/FORM/">First-Order Reliability Methods</a></li><li><a class="tocitem" href="../Reliability Problems/SORM/">Second-Order Reliability Methods</a></li><li><a class="tocitem" href="../Reliability Problems/SSM/">Subset Simulation Method</a></li></ul></li><li><a class="tocitem" href="../InverseReliabilityProblems/">Inverse Reliability Problems</a></li><li><a class="tocitem" href="../SensitivityProblems/">Sensitivity Problems</a></li><li><a class="tocitem" href="../BasicExamples/">Basic Examples</a></li><li class="is-active"><a class="tocitem" href>Advanced Usage</a><ul class="internal"><li><a class="tocitem" href="#&quot;Internal&quot;-Finite-Element-Models"><span>&quot;Internal&quot; Finite Element Models</span></a></li><li><a class="tocitem" href="#&quot;External&quot;-Finite-Element-Models"><span>&quot;External&quot; Finite Element Models</span></a></li><li><a class="tocitem" href="#Surrogate-Models"><span>Surrogate Models</span></a></li></ul></li><li><a class="tocitem" href="../Research/">Research</a></li><li><a class="tocitem" href="../References/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Advanced Usage</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Advanced Usage</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/AkchurinDA/Fortuna.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/AkchurinDA/Fortuna.jl/blob/main/docs/src/AdvancedUsage.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Advanced-Usage"><a class="docs-heading-anchor" href="#Advanced-Usage">Advanced Usage</a><a id="Advanced-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-Usage" title="Permalink"></a></h1><h2 id="&quot;Internal&quot;-Finite-Element-Models"><a class="docs-heading-anchor" href="#&quot;Internal&quot;-Finite-Element-Models">&quot;Internal&quot; Finite Element Models</a><a id="&quot;Internal&quot;-Finite-Element-Models-1"></a><a class="docs-heading-anchor-permalink" href="#&quot;Internal&quot;-Finite-Element-Models" title="Permalink"></a></h2><p>The real power of <code>Fortuna.jl</code> package comes from the ability to define limit state functions using finite element (FE) models of complex systems. For example, if the roof drift of a frame subjected to wind loads <span>$\Delta$</span> must not exceed a certain limit <span>$\Delta_{0}$</span>, then the limit state function is given by <span>$g(\vec{X}) = \Delta_{0} - \Delta(\vec{X})$</span>, where <span>$\Delta$</span> must be computed from the FE model of this frame with a proper consideration of all random variables involved in the problem formulation <span>$\vec{X}$</span>. </p><p><code>Fortuna.jl</code> package allows you to easily solve reliability problems for FE models built using any Julia package with such capabilities, e.g., <a href="https://github.com/runtosolve/InstantFrame.jl"><code>InstantFrame.jl</code></a> and <a href="https://github.com/ONSAS/ONSAS.jl"><code>ONSAS.jl</code></a> packages for structural system problems, <a href="https://github.com/NREL-Sienna/PowerSystems.jl"><code>PowerSystems.jl</code></a> package for power system problems, <a href="https://github.com/gridap/Gridap.jl"><code>Gridap.jl</code></a> package for more general FE problems, and many more. Moreover, thanks to the great Julia-to-Python infrastructure developed by the <a href="https://github.com/JuliaPy"><code>JuliaPy</code></a> organization, you can also build FE models using Python packages with such capabilities. The most prominent example of such Python package is, of course, <a href="https://github.com/zhuminjie/OpenSeesPy"><code>OpenSeesPy</code></a> which serves as the standard to simulate the performance of structural and geotechnical systems subjected to earthquakes.</p><h3 id="Julia-Based-FE-Models:-InstantFrame.jl"><a class="docs-heading-anchor" href="#Julia-Based-FE-Models:-InstantFrame.jl">Julia-Based FE Models: <code>InstantFrame.jl</code></a><a id="Julia-Based-FE-Models:-InstantFrame.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-Based-FE-Models:-InstantFrame.jl" title="Permalink"></a></h3><h4 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h4><p>To install <code>InstantFrame.jl</code> package, type <code>]</code> in Julia REPL to enter the built-in Julia package manager and execute the following command:</p><pre><code class="nohighlight hljs">pkg&gt; add InstantFrame</code></pre><h4 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h4><p>Consider a cantilever beam subjected to simultaneous axial and transverse loading based on the example provided in <a href="../References/#Denavit:2013">Denavit and Hajjar (2013)</a> with the only difference that Young&#39;s modulus <span>$E = X_{1}$</span> and moment of inertia about major axis <span>$I = X_{2}$</span> are uncorrelated normally-distributed random variables. The cross-sectional area of the beam <span>$A$</span> is <span>$9.12 \text{ in.}^{2}$</span>.</p><img src="../assets/Examples-AdvancedUsage-1.png" class="center" style="max-height:350px; border-radius:2.5px;"/><p>Let&#39;s define the limit state function as </p><p class="math-container">\[g(\vec{X}) = \Delta_{0} - \Delta(\vec{X})\]</p><p>where <span>$\Delta(\vec{X})$</span> is the downward deflection at the free end of the beam, which must not exceed the deflection limit <span>$\Delta_{0}$</span> of <span>$1 \text{ in.}$</span>. The goal of this example is to find the reliability indices <span>$\beta$</span> and probabilities of failure <span>$P_{f}$</span> using First- and Second-Order Reliability Methods.</p><pre><code class="language-julia hljs"># Preamble:
using Fortuna
using InstantFrame

# Define the random variables:
X₁ = randomvariable(&quot;Normal&quot;, &quot;M&quot;, [29000, 0.05 * 29000]) # Young&#39;s modulus
X₂ = randomvariable(&quot;Normal&quot;, &quot;M&quot;, [  110, 0.05 *   110]) # Moment of inertia about major-axis
X  = [X₁, X₂]

# Define the correlation matrix:
ρˣ = [1 0; 0 1]

# Define the FE model of the cantilever beam:
function CantileverBeam(x::Vector)
    # Define the material properties:
    Material = InstantFrame.Material(
        names = [&quot;Steel&quot;],
        E     = [x[1]],
        ν     = [0.3],
        ρ     = [0])

    # Define the cross-sectional properties:
    CrossSection = InstantFrame.CrossSection(
        names = [&quot;Beam&quot;],
        A     = [9.12],
        Iy    = [0],
        Iz    = [x[2]],
        J     = [0])

    # Define the element-to-element connections:
    Connection = InstantFrame.Connection(
        names     = [&quot;Rigid&quot;],
        stiffness = (ux = [Inf], uy = [Inf], uz = [Inf], rx = [Inf], ry = [Inf], rz = [Inf]))

    # Define the nodes:
    Node = InstantFrame.Node(
        numbers     = 1:11,
        coordinates = [
            (  0, 0, 0),
            ( 18, 0, 0),
            ( 36, 0, 0),
            ( 54, 0, 0),
            ( 72, 0, 0),
            ( 90, 0, 0),
            (108, 0, 0),
            (126, 0, 0),
            (144, 0, 0),
            (162, 0, 0),
            (180, 0, 0)])

    # Define the elements:
    Element = InstantFrame.Element(
        types         = [&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;],
        numbers       = 1:10,
        nodes         = [
            ( 1,  2),
            ( 2,  3),
            ( 3,  4),
            ( 4,  5),
            ( 5,  6),
            ( 6,  7),
            ( 7,  8),
            ( 8,  9),
            ( 9, 10),
            (10, 11)],
        orientation   = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        connections   = [
            (&quot;Rigid&quot;, &quot;Rigid&quot;),
            (&quot;Rigid&quot;, &quot;Rigid&quot;),
            (&quot;Rigid&quot;, &quot;Rigid&quot;),
            (&quot;Rigid&quot;, &quot;Rigid&quot;),
            (&quot;Rigid&quot;, &quot;Rigid&quot;),
            (&quot;Rigid&quot;, &quot;Rigid&quot;),
            (&quot;Rigid&quot;, &quot;Rigid&quot;),
            (&quot;Rigid&quot;, &quot;Rigid&quot;),
            (&quot;Rigid&quot;, &quot;Rigid&quot;),
            (&quot;Rigid&quot;, &quot;Rigid&quot;)],
        cross_section = [ &quot;Beam&quot;,  &quot;Beam&quot;,  &quot;Beam&quot;,  &quot;Beam&quot;,  &quot;Beam&quot;,  &quot;Beam&quot;,  &quot;Beam&quot;,  &quot;Beam&quot;,  &quot;Beam&quot;,  &quot;Beam&quot;],
        material      = [&quot;Steel&quot;, &quot;Steel&quot;, &quot;Steel&quot;, &quot;Steel&quot;, &quot;Steel&quot;, &quot;Steel&quot;, &quot;Steel&quot;, &quot;Steel&quot;, &quot;Steel&quot;, &quot;Steel&quot;])

    # Define the boundary conditions:
    Support = InstantFrame.Support(
        nodes     = 1:11,
        stiffness = (
            uX = [Inf,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0],
            uY = [Inf,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0],
            uZ = [Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf],
            rX = [Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf],
            rY = [Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf, Inf],
            rZ = [Inf,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0]))

    # Define the distributed loads:
    UniformLoad = InstantFrame.UniformLoad(nothing)

    # Define the concentrated loads:
    PointLoad = InstantFrame.PointLoad(
        labels     = [&quot;&quot;],
        nodes      = [11],
        magnitudes = (FX = [-50], FY = [-1], FZ = [0], MX = [0], MY = [0], MZ = [0]))

    # Solve:
    Model = InstantFrame.solve(Node, CrossSection, Material, Connection, Element, Support, UniformLoad, PointLoad, analysis_type = &quot;second order&quot;, solution_tolerance = 1E-6)

    # Get the vertical displacement at the free end:
    Δ = -Model.solution.displacements[11][2]

    return Δ
end

# Define the limit state function:
g(x::Vector) = 1 - CantileverBeam(x)

# Define the reliability problem:
Problem = ReliabilityProblem(X, ρˣ, g)

# Perform the reliability analysis using the FORM:
FORMSolution = solve(Problem, FORM(), diff = :numeric)
println(&quot;FORM:&quot;)
println(&quot;β: $(FORMSolution.β)&quot;)
println(&quot;PoF: $(FORMSolution.PoF)&quot;)

# Perform the reliability analysis using the SORM:
SORMSolution = solve(Problem, SORM(), FORMSolution = FORMSolution, diff = :numeric)
println(&quot;SORM:&quot;)
println(&quot;β: $(SORMSolution.β₂[1]) (Hohenbichler and Rackwitz)&quot;)
println(&quot;β: $(SORMSolution.β₂[2]) (Breitung)&quot;)
println(&quot;PoF: $(SORMSolution.PoF₂[1]) (Hohenbichler and Rackwitz)&quot;)
println(&quot;PoF: $(SORMSolution.PoF₂[2]) (Breitung)&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ Warning: Solving Linear System A::Matrix{Float64} x::StaticArraysCore.SVector{30, Float64} = b::StaticArraysCore.SVector{30, Float64} is not properly supported. Converting `x` to a mutable array. Check the return type of the nonlinear function provided for optimal performance.
└ @ NonlinearSolve ~/.julia/packages/NonlinearSolve/R4GRC/src/internal/linear_solve.jl:59
FORM:
β: 2.778812477316028
PoF: 0.0027279005403556024
┌ Warning: Solving Linear System A::Matrix{Float64} x::StaticArraysCore.SVector{30, Float64} = b::StaticArraysCore.SVector{30, Float64} is not properly supported. Converting `x` to a mutable array. Check the return type of the nonlinear function provided for optimal performance.
└ @ NonlinearSolve ~/.julia/packages/NonlinearSolve/R4GRC/src/internal/linear_solve.jl:59
SORM:
β: 2.757857066145941 (Hohenbichler and Rackwitz)
β: 2.76002459211157 (Breitung)
PoF: 0.0029090816006080854 (Hohenbichler and Rackwitz)
PoF: 0.0028898505306156133 (Breitung)</code></pre><p>Observe that <code>diff = :numeric</code> keyword argument was used in <code>solve()</code> function. This forces <code>Fortuna.jl</code> package to use numerical differentiation to evaluate the gradients and Hessians of the limit state function since the finite element (FE) model of the cantilever beam, defined using <code>InstantFrame.jl</code> package, is not automatically differentiable. Note that you would still obtain a solution if you didn&#39;t use <code>diff = :numeric</code> keyword argument, but each time <code>Fortuna.jl</code> package needs to differentiate the limit state function, it would (1) attempt to differentiate it automatically, and after it fails, (2) it would differentiate it numerically, significantly slowing down the reliability analysis.</p><h3 id="Python-Based-FE-Models:-OpenSeesPy"><a class="docs-heading-anchor" href="#Python-Based-FE-Models:-OpenSeesPy">Python-Based FE Models: <code>OpenSeesPy</code></a><a id="Python-Based-FE-Models:-OpenSeesPy-1"></a><a class="docs-heading-anchor-permalink" href="#Python-Based-FE-Models:-OpenSeesPy" title="Permalink"></a></h3><h4 id="Installation-2"><a class="docs-heading-anchor" href="#Installation-2">Installation</a><a class="docs-heading-anchor-permalink" href="#Installation-2" title="Permalink"></a></h4><p>To be able to work with <a href="https://openseespydoc.readthedocs.io/en/latest/"><code>OpenSeesPy</code></a> package directly from Julia you need to install two packages that allow Julia to talk to Python: </p><table><tr><th style="text-align: left">Package</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><a href="https://github.com/JuliaPy/PyCall.jl"><code>PyCall.jl</code></a></td><td style="text-align: left">Let&#39;s you call Python functions directly from Julia</td></tr><tr><td style="text-align: left"><a href="https://github.com/JuliaPy/Conda.jl"><code>Conda.jl</code></a></td><td style="text-align: left">Let&#39;s you install Python packages from <code>conda</code> and <code>pip</code> package managers that can be then called directly from Julia using <code>PyCall.jl</code> package</td></tr></table><p>To install <code>PyCall.jl</code> and <code>Conda.jl</code> packages, type <code>]</code> in Julia REPL to enter the built-in Julia package manager and execute the following command:</p><pre><code class="nohighlight hljs">pkg&gt; add PyCall Conda</code></pre><p>Now you need to install <code>OpenSeesPy</code> package through <code>Conda.jl</code> package. To do that, run the following commands in Julia REPL:</p><pre><code class="language-julia hljs">using Conda
Conda.pip_interop(true)            # Activate &quot;pip&quot;
Conda.pip(&quot;install&quot;, &quot;openseespy&quot;) # Install OpenSeesPy using &quot;pip&quot;</code></pre><p>Now you can work with <code>OpenSeesPy</code> package directly from Julia!</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If you are experiencing any problems installing <code>OpenSeesPy</code> package please refer to <code>Conda.jl</code> package&#39;s <a href="https://github.com/JuliaPy/Conda.jl">documentation</a>.</p></div></div><h4 id="Example-2"><a class="docs-heading-anchor" href="#Example-2">Example</a><a class="docs-heading-anchor-permalink" href="#Example-2" title="Permalink"></a></h4><p>Let&#39;s solve previously defined problem using <code>OpenSeesPy</code> package.</p><pre><code class="language-julia hljs"># Preamble:
using Fortuna
using PyCall

# Load OpenSeesPy package:
ops = pyimport(&quot;openseespy.opensees&quot;)

# Define the random variables:
X₁ = randomvariable(&quot;Normal&quot;, &quot;M&quot;, [29000, 0.05 * 29000]) # Young&#39;s modulus
X₂ = randomvariable(&quot;Normal&quot;, &quot;M&quot;, [  110, 0.05 *   110]) # Moment of inertia about major axis
X  = [X₁, X₂]

# Define the correlation matrix:
ρˣ = [1 0; 0 1]

# Define the FE model of the cantilever beam:
function CantileverBeam(x::Vector)
    # Remove any previous models:
    ops.wipe()

    # Define the model parameters:
    ops.model(&quot;basic&quot;, &quot;-ndm&quot;, 2, &quot;-ndf&quot;, 3)

    # Define the nodes:
    ops.node( 1,   0, 0)
    ops.node( 2,  18, 0)
    ops.node( 3,  36, 0)
    ops.node( 4,  54, 0)
    ops.node( 5,  72, 0)
    ops.node( 6,  90, 0)
    ops.node( 7, 108, 0)
    ops.node( 8, 126, 0)
    ops.node( 9, 144, 0)
    ops.node(10, 162, 0)
    ops.node(11, 180, 0)

    # Define the boundary conditions:
    ops.fix(1, 1, 1, 1)

    # Define the cross-sectional properties:
    A = 9.12
    ops.section(&quot;Elastic&quot;,  1, x[1], A, x[2])

    # Define the transformation:
    ops.geomTransf(&quot;PDelta&quot;, 1)

    # Define the elements:
    ops.element(&quot;elasticBeamColumn&quot;,  1,  1,  2,  1, 1)
    ops.element(&quot;elasticBeamColumn&quot;,  2,  2,  3,  1, 1)
    ops.element(&quot;elasticBeamColumn&quot;,  3,  3,  4,  1, 1)
    ops.element(&quot;elasticBeamColumn&quot;,  4,  4,  5,  1, 1)
    ops.element(&quot;elasticBeamColumn&quot;,  5,  5,  6,  1, 1)
    ops.element(&quot;elasticBeamColumn&quot;,  6,  6,  7,  1, 1)
    ops.element(&quot;elasticBeamColumn&quot;,  7,  7,  8,  1, 1)
    ops.element(&quot;elasticBeamColumn&quot;,  8,  8,  9,  1, 1)
    ops.element(&quot;elasticBeamColumn&quot;,  9,  9, 10,  1, 1)
    ops.element(&quot;elasticBeamColumn&quot;, 10, 10, 11,  1, 1)

    # Define the loads:
    ops.timeSeries(&quot;Linear&quot;, 1)
    ops.pattern(&quot;Plain&quot;, 1, 1)
    ops.load(11,   0, -1, 0)
    ops.load(11, -50,  0, 0)

    # Define the solver parameters:
    ops.system(&quot;BandSPD&quot;)
    ops.numberer(&quot;RCM&quot;)
    ops.constraints(&quot;Plain&quot;)
    ops.algorithm(&quot;Linear&quot;)

    # Solve:
    ops.integrator(&quot;LoadControl&quot;, 0.01)
    ops.analysis(&quot;Static&quot;)
    ops.analyze(100)

    # Get the vertical displacement at the free end:
    Δ = -ops.nodeDisp(11, 2)

    # Return the result:
    return Δ
end

# Define the limit state function:
g(x::Vector) = 1 - CantileverBeam(x)

# Define the reliability problem:
Problem = ReliabilityProblem(X, ρˣ, g)

# Perform the reliability analysis using the FORM:
FORMSolution = solve(Problem, FORM(), diff = :numeric)
println(&quot;FORM:&quot;)
println(&quot;β: $(FORMSolution.β)&quot;)
println(&quot;PoF: $(FORMSolution.PoF)&quot;)

# Perform the reliability analysis using the SORM:
SORMSolution = solve(Problem, SORM(), FORMSolution = FORMSolution, diff = :numeric)
println(&quot;SORM:&quot;)
println(&quot;β: $(SORMSolution.β₂[1]) (Hohenbichler and Rackwitz)&quot;)
println(&quot;β: $(SORMSolution.β₂[2]) (Breitung)&quot;)
println(&quot;PoF: $(SORMSolution.PoF₂[1]) (Hohenbichler and Rackwitz)&quot;)
println(&quot;PoF: $(SORMSolution.PoF₂[2]) (Breitung)&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">FORM:
β: 2.8174295342638143
PoF: 0.002420486801646781
SORM:
β: 2.7964225995564593 (Hohenbichler and Rackwitz)
β: 2.7985512087326656 (Breitung)
PoF: 0.0025835893047366763 (Hohenbichler and Rackwitz)
PoF: 0.0025666214553221878 (Breitung)</code></pre><h2 id="&quot;External&quot;-Finite-Element-Models"><a class="docs-heading-anchor" href="#&quot;External&quot;-Finite-Element-Models">&quot;External&quot; Finite Element Models</a><a id="&quot;External&quot;-Finite-Element-Models-1"></a><a class="docs-heading-anchor-permalink" href="#&quot;External&quot;-Finite-Element-Models" title="Permalink"></a></h2><p>Besides being able to define limit state functions using FE models of complex systems using Julia- and Python-based FE softwares, it also possible to define FE models using external FE software, most notably Tcl-based <a href="https://en.wikipedia.org/wiki/OpenSees"><code>OpenSees</code></a>, <a href="https://en.wikipedia.org/wiki/Abaqus"><code>Abaqus</code></a>, and <a href="https://www.uee.uliege.be/cms/c_10613577/fr/uee-safir"><code>SAFIR</code></a>. </p><p>In general, the following approach is taken to solve reliability problems involving FE models built using <code>OpenSees</code>, <code>Abaqus</code>, and <code>SAFIR</code> softwares in <code>Fortuna.jl</code> packages:</p><ul><li>Input files describing the models are created: <code>.tcl</code> in case of <code>OpenSees</code>, <code>.inp</code> in case of <code>Abaqus</code>, <code>.in</code> in case of <code>SAFIR</code>. The random variables involved in the definition of a model are defined using <em>unique</em> &quot;placeholders&quot; in model&#39;s input file. These &quot;placeholders&quot; are then used to inject samples of corresponding random variables to create executable files. For example, &quot;placeholder&quot; for Young&#39;s modulus in the definition of a FE model built using <code>Abaqus</code> may look like <code>:E</code> because <code>:</code> symbol generally does not appear in <code>.inp</code> files; thus, the section describing the material properties of a model in the associated <code>ExampleModel.inp</code> file will look like:</li></ul><pre><code class="nohighlight hljs">...
*MATERIAL, NAME=STEEL
*ELASTIC
:E, 0.3
...</code></pre><ul><li>Random variables are then sampled and a temporary input file with samples injected in place of &quot;placeholders&quot; is created. Following the example from above, if the Young&#39;s modulus is a normally-distributed random variable with mean of 29000 ksi and coefficient of variation of 0.05, then the section describing the material properties of the model in the temporary <code>ExampleModelTemp.inp</code> input file with a sample of this random variable of 27569.312 already injected will look like:</li></ul><pre><code class="nohighlight hljs">...
*MATERIAL, NAME=STEEL
*ELASTIC
27569.312, 0.3
...</code></pre><ul><li>These temporary input files with samples injected in place of &quot;placeholders&quot; are now executable and can used to evaluate the defined model using Julia&#39;s <code>run()</code> and <code>pipeline()</code> functions: <code>run()</code> function allows to execute commands directly from Julia and <code>pipeline()</code> function directs all unwanted text created by external FE softwares elsewhere. For example, the model defined in the temporary <code>ExampleModelTemp.inp</code> input file can be executed using the following command in Julia given that Abaqus&#39; execution files are added to your system&#39;s path:</li></ul><pre><code class="nohighlight hljs">run(pipeline(`cmd /C &quot;abaqus interactive job=ExampleModelTemp&quot;`,
    stdout = devnull,
    stderr = devnull))</code></pre><ul><li>After the model defined in the temporary input file is executed, we need to process the output file (<code>.out</code> file created by <a href="https://opensees.berkeley.edu/wiki/index.php/Recorder_Command"><code>recorder</code></a> function for <code>OpenSees</code>, <code>.odb</code> created by <code>Abaqus</code>, or <code>.out</code> created by <code>SAFIR</code>) to get the output variable of interest involved in the definition of the associated limit state function. <ul><li>In case of <code>OpenSees</code> and <code>SAFIR</code>, everything is quite easy since <code>.out</code> files are text-based and can be read directly in Julia, for example, using <a href="https://github.com/JuliaData/DelimitedFiles.jl?tab=readme-ov-file"><code>DelimitedFiles.jl</code></a> package. </li><li>In case of <code>Abaqus</code>, there need to be an additional Python script that reads binary <code>.odb</code> files and produces text-based files that can be read by Julia.</li></ul></li></ul><p>After that, a FE model can be easily used to define an associated limit state function and solve the reliability problem of interest.</p><h3 id="OpenSees"><a class="docs-heading-anchor" href="#OpenSees"><code>OpenSees</code></a><a id="OpenSees-1"></a><a class="docs-heading-anchor-permalink" href="#OpenSees" title="Permalink"></a></h3><h4 id="Installation-3"><a class="docs-heading-anchor" href="#Installation-3">Installation</a><a class="docs-heading-anchor-permalink" href="#Installation-3" title="Permalink"></a></h4><p>Tcl-based <code>OpenSees</code> can be installed from its official website <a href="https://opensees.berkeley.edu">here</a>.</p><h4 id="Example-3"><a class="docs-heading-anchor" href="#Example-3">Example</a><a class="docs-heading-anchor-permalink" href="#Example-3" title="Permalink"></a></h4><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The base <code>CantileverBeam.tcl</code> input file can be found <a href="https://github.com/AkchurinDA/Fortuna.jl/tree/main/examples/OpenSees/CantileverBeam.tcl">here</a>.</p></div></div><p>Let&#39;s solve previously defined problem using <code>OpenSees</code> by constructing <code>CantileverBeam(x::Vector)</code> function, which:</p><ol><li>Injects samples <code>x</code> into the base <code>CantileverBeam.tcl</code> input file in place of <code>:E</code> (Young&#39;s modulus) and <code>:I</code> (moment of inertia) &quot;placeholders&quot;.</li><li>Creates a temporary <code>CantileverBeamTemp.tcl</code> input file.</li><li>Executes the temporary input file using <code>OpenSees</code>.</li><li>Reads and return the vertical displacement at the free end of the beam stored in <code>Output.out</code> file created by the <code>recorder</code> function.</li></ol><pre><code class="language-julia hljs"># Define the FE model of the cantilever beam:
OpenSeesPath  = &quot;C:\\Users\\...\\bin\\OpenSees&quot; # This must be an absolute path!
WorkDirectory = &quot;C:\\Users\\...&quot;                # This must be an absolute path!
IFilename     = &quot;CantileverBeam.tcl&quot;
OFilename     = &quot;Output.out&quot;
Placeholders  = [&quot;:E&quot;, &quot;:I&quot;]
function CantileverBeam(x::Vector)
    # Inject values into the input file:
    IFileString = read(joinpath(WorkDirectory, IFilename), String)
    for (Placeholder, Value) in zip(Placeholders, x)
        IFileString = replace(IFileString, Placeholder =&gt; string(Value))
    end

    # Write the modified input file:
    TempIFilename = replace(IFilename, &quot;.tcl&quot; =&gt; &quot;Temp.tcl&quot;)
    write(joinpath(WorkDirectory, TempIFilename), IFileString)

    # Run the model from the work directory:
    cd(WorkDirectory)
    run(pipeline(`$(OpenSeesPath) $(joinpath(WorkDirectory, TempIFilename))`, 
        stdout = devnull,
        stderr = devnull))
    
    # Extract the output:
    Δ = -readdlm(joinpath(WorkDirectory, OFilename))[end]

    # Delete the created files to prevent cluttering the work directory:
    rm(joinpath(WorkDirectory, TempIFilename))
    rm(joinpath(WorkDirectory,     OFilename))

    # Return the result:
    return Δ
end</code></pre><h3 id="Abaqus"><a class="docs-heading-anchor" href="#Abaqus"><code>Abaqus</code></a><a id="Abaqus-1"></a><a class="docs-heading-anchor-permalink" href="#Abaqus" title="Permalink"></a></h3><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>It is recommended to avoid using <code>Abaqus</code> for relatively inexpensive FE models due to the significant overhead caused by <code>Abaqus</code>&#39; intense I/O usage. Use <code>Abaqus</code> only when the FE model is extremely expensive, making the trade-off worth it; otherwise, use a different solver.</p></div></div><h4 id="Installation-4"><a class="docs-heading-anchor" href="#Installation-4">Installation</a><a class="docs-heading-anchor-permalink" href="#Installation-4" title="Permalink"></a></h4><p><code>Abaqus</code> can be installed from Dassault Systems&#39; official website <a href="https://www.3ds.com/products/simulia/abaqus">here</a>. Note that a student version of Abaqus is available for free and can be installed from <a href="https://www.3ds.com/edu/education/students/solutions/abaqus-le">here</a>. If you work at a research institution, please check if <code>Abaqus</code> is available through your institution, which is typically a better option, because you can typically get from your IT department on installation and licensing.</p><h4 id="Example-4"><a class="docs-heading-anchor" href="#Example-4">Example</a><a class="docs-heading-anchor-permalink" href="#Example-4" title="Permalink"></a></h4><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The base <code>CantileverBeam.inp</code> input file can be found <a href="https://github.com/AkchurinDA/Fortuna.jl/tree/main/examples/OpenSees/CantileverBeam.tcl">here</a> and <code>CantileverBeam.py</code> Python script can be found <a href="https://github.com/AkchurinDA/Fortuna.jl/tree/main/examples/OpenSees/CantileverBeam.py">here</a>.</p></div></div><p>Let&#39;s solve previously defined problem using <code>Abaqus</code> by constructing <code>CantileverBeam(x::Vector)</code> function, which:</p><ol><li>Injects samples <code>x</code> into the base <code>CantileverBeam.inp</code> input file in place of <code>:E</code> (Young&#39;s modulus) and <code>:I</code> (moment of inertia) &quot;placeholders&quot;.</li><li>Creates a temporary <code>CantileverBeamTemp.inp</code> input file.</li><li>Executes the temporary input file using <code>Abaqus</code>.</li><li>Executes an additional <code>CantileverBeam.py</code> Python script that reads binary <code>CantileverBeamTemp.odb</code> files and produces Julia-readable <code>Output.txt</code> file.</li><li>Reads and return the vertical displacement at the free end of the beam stored in <code>Output.txt</code> file.</li></ol><pre><code class="language-julia hljs"># Define the FE model of the cantilever beam:
WorkDirectory = &quot;C:\\Users\\...&quot; # This must be an absolute path!
PYFilename    = &quot;CantileverBeam.py&quot;
IFilename     = &quot;CantileverBeam.inp&quot;
OFilename     = &quot;Output.txt&quot;
Placeholders  = [&quot;:E&quot;, &quot;:I&quot;]
function CantileverBeam(x::Vector)
    # Inject values into the input file:
    IFileString = read(joinpath(WorkDirectory, IFilename), String)
    for (Placeholder, Value) in zip(Placeholders, x)
        IFileString = replace(IFileString, Placeholder =&gt; string(Value))
    end

    # Write the modified input file:
    TempIFilename = replace(IFilename, &quot;.inp&quot; =&gt; &quot;Temp.inp&quot;)
    write(joinpath(WorkDirectory, TempIFilename), IFileString)

    # Run the model from the work directory:
    cd(WorkDirectory)
    run(pipeline(`cmd /c &quot;abaqus interactive job=$(replace(TempIFilename, &quot;.inp&quot; =&gt; &quot;&quot;))&quot;`,
        stdout = devnull,
        stderr = devnull))

    # Extract the output:
    run(pipeline(`cmd /c &quot;abaqus cae noGUI=$(PYFilename)&quot;`,
        stdout = devnull,
        stderr = devnull))
    Δ = -readdlm(joinpath(WorkDirectory, OFilename))[end]

    # Delete the created files to prevent cluttering the work directory:
    rm(joinpath(WorkDirectory, TempIFilename))
    rm(joinpath(WorkDirectory,     OFilename))

    # Return the result:
    return Δ
end</code></pre><h3 id="SAFIR"><a class="docs-heading-anchor" href="#SAFIR"><code>SAFIR</code></a><a id="SAFIR-1"></a><a class="docs-heading-anchor-permalink" href="#SAFIR" title="Permalink"></a></h3><h4 id="Installation-5"><a class="docs-heading-anchor" href="#Installation-5">Installation</a><a class="docs-heading-anchor-permalink" href="#Installation-5" title="Permalink"></a></h4><p><code>SAFIR</code> (<a href="../References/#Franssen:2017">Franssen and Gernay, 2017</a>) can be installed from its official website <a href="https://www.gesval.be/en/catalogue">here</a>.</p><h4 id="Example-5"><a class="docs-heading-anchor" href="#Example-5">Example</a><a class="docs-heading-anchor-permalink" href="#Example-5" title="Permalink"></a></h4><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The base <code>FrameUnderFire.IN</code> input file can be found <a href="https://github.com/AkchurinDA/Fortuna.jl/tree/main/examples/SAFIR/FrameUnderFire.IN">here</a>.</p></div></div><p>Consider a frame with steel beam and concrete columns based on this <a href="https://mars.jhu.edu/wp-content/uploads/2018/10/SAFIR_Training-3D-Beam.pdf">example</a> (courtesy of <a href="https://engineering.jhu.edu/faculty/thomas-gernay/">Dr. Thomas Gernay</a>). The columns and beam are exposed to ASTM E119 standard fire on 3 faces. The frame&#39;s bases are fixed. The only difference is that the Young&#39;s modulus <span>$E = X_{1}$</span> and lateral load <span>$F = X_{2}$</span> are uncorrelated normally-distributed random variables.</p><img src="../assets/Examples-AdvancedUsage-2.png" class="center" style="max-height:350px; border-radius:2.5px;"/><p>Let&#39;s solve the defined problem using <code>SAFIR</code> by constructing <code>FrameUnderFire(x::Vector)</code> function, which:</p><ol><li>Injects samples <code>x</code> into the base <code>FrameUnderFire.IN</code> input file in place of <code>:E</code> (Young&#39;s modulus) and <code>:F</code> (lateral load) &quot;placeholders&quot;.</li><li>Creates a temporary <code>FrameUnderFireTemp.IN</code> input file.</li><li>Executes the temporary input file using <code>SAFIR</code>.</li><li>Reads and return the vertical displacement at the midpoint of the beam stored in <code>FrameUnderFireTemp.OUT</code> file.</li></ol><pre><code class="language-julia hljs"># Define the FE model of the frame under fire:
WorkDirectory = &quot;C:\\Users\\...&quot; # This must be an absolute path!
IFilename     = &quot;FrameUnderFire.IN&quot;
OFilename     = &quot;FrameUnderFireTemp.out&quot;
Placeholders  = [&quot;:E&quot;, &quot;:F&quot;]
function FrameUnderFire(x::Vector)
    # Inject values into the input file:
    IFileString = read(joinpath(WorkDirectory, IFilename), String)
    for (Placeholder, Value) in zip(Placeholders, x)
        IFileString = replace(IFileString, Placeholder =&gt; string(Value))
    end

    # Write the modified input file:
    TempIFilename = replace(IFilename, &quot;.IN&quot; =&gt; &quot;Temp.IN&quot;)
    write(joinpath(WorkDirectory, TempIFilename), IFileString)

    # Run the model from the work directory:
    cd(WorkDirectory)
    run(pipeline(`cmd /C &quot;SAFIR $(replace(TempIFilename, &quot;.IN&quot; =&gt; &quot;&quot;))&quot;`, 
        stdout = devnull,
        stderr = devnull))
    
    # Extract the output:
    OFileString = read(OFilename, String)
    SIndex      = findlast(&quot;TOTAL DISPLACEMENTS.\r\n --------------------\r\n NODE    DOF 1     DOF 2     DOF 3     DOF 4     DOF 5     DOF 6     DOF 7\r\n&quot;, OFileString)
    OFileString = OFileString[(SIndex[end] + 1):end]
    FIndex      = findfirst(&quot;\r\n\r\n&quot;, OFileString)
    OFileString = OFileString[1:(FIndex[1] - 1)]
    write(joinpath(WorkDirectory, OFilename), OFileString)
    Δ = -readdlm(joinpath(WorkDirectory, OFilename))[38, 3]

    # Delete the created files to prevent cluttering the work directory:
    rm(joinpath(WorkDirectory, TempIFilename))
    rm(joinpath(WorkDirectory,     OFilename))

    # Return the result:
    return Δ
end</code></pre><h2 id="Surrogate-Models"><a class="docs-heading-anchor" href="#Surrogate-Models">Surrogate Models</a><a id="Surrogate-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Surrogate-Models" title="Permalink"></a></h2><p>Most of the time, FE models are very expensive to evaluate, especially when it comes to differentiation of such FE models for the purposes of reliability analysis. Instead, it is possible to build a surrogate of a FE model. For example, <a href="https://github.com/SciML/Surrogates.jl"><code>Surrogates.jl</code></a> package allows you to build surrogate models. The most important feature of <code>Surrogates.jl</code> package is that it permits automatic differentiation of a surrogates model even if the underlying FE model cannot be differentiated automatically, which significantly speeds up the reliability analysis!</p><h4 id="Example-6"><a class="docs-heading-anchor" href="#Example-6">Example</a><a class="docs-heading-anchor-permalink" href="#Example-6" title="Permalink"></a></h4><p>Let&#39;s build a Kriging surrogate model of the FE model of the cantilever beam built earlier using <code>OpenSeesPy</code> package and solve for the reliability indices <span>$\beta$</span> and probabilities of failure <span>$P_{f}$</span> using First- and Second-Order Reliability Methods again.</p><pre><code class="language-julia hljs"># Preamble:
using Surrogates

# Define the training points:
LowerBound = [
    29000 - 6 * 0.05 * 29000,
      110 - 6 * 0.05 *   110]
UpperBound = [
    29000 + 6 * 0.05 * 29000,
      110 + 6 * 0.05 *   110]
XTrain = sample(50, LowerBound, UpperBound, SobolSample())
YTrain = [CantileverBeam([x...]) for x in XTrain]

# Fit a Kriging surrogate model to the training points:
CantileverBeamSurrogate = Kriging(XTrain, YTrain, LowerBound, UpperBound)

# Define the limit state function using the surrogate model:
ĝ(x::Vector) = 1 - CantileverBeamSurrogate(x)

# Define the reliability problem:
Problem = ReliabilityProblem(X, ρˣ, ĝ)

# Perform the reliability analysis using the FORM:
FORMSolution = solve(Problem, FORM(), diff = :numeric)
println(&quot;FORM:&quot;)
println(&quot;β: $(FORMSolution.β)&quot;)
println(&quot;PoF: $(FORMSolution.PoF)&quot;)

# Perform the reliability analysis using the SORM:
SORMSolution = solve(Problem, SORM(), FORMSolution = FORMSolution, diff = :numeric)
println(&quot;SORM:&quot;)
println(&quot;β: $(SORMSolution.β₂[1]) (Hohenbichler and Rackwitz)&quot;)
println(&quot;β: $(SORMSolution.β₂[2]) (Breitung)&quot;)
println(&quot;PoF: $(SORMSolution.PoF₂[1]) (Hohenbichler and Rackwitz)&quot;)
println(&quot;PoF: $(SORMSolution.PoF₂[2]) (Breitung)&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">FORM:
β: 2.8171236020402812
PoF: 0.0024227936943037017
SORM:
β: 2.7981732416559044 (Hohenbichler and Rackwitz)
β: 2.8000821093600052 (Breitung)
PoF: 0.002569626982629006 (Hohenbichler and Rackwitz)
PoF: 0.0025544804724711248 (Breitung)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../BasicExamples/">« Basic Examples</a><a class="docs-footer-nextpage" href="../Research/">Research »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Wednesday 26 June 2024 19:07">Wednesday 26 June 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
