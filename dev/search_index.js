var documenterSearchIndex = {"docs":
[{"location":"IsoprobabilisticTransformations/NatafTransformation/#Nataf-Transformation","page":"Nataf Transformation","title":"Nataf Transformation","text":"","category":"section"},{"location":"IsoprobabilisticTransformations/NatafTransformation/#Overview","page":"Nataf Transformation","title":"Overview","text":"","category":"section"},{"location":"IsoprobabilisticTransformations/NatafTransformation/","page":"Nataf Transformation","title":"Nataf Transformation","text":"The Nataf Transformation is a widely utilized isoprobabilistic transformation in structural reliability analysis. Its purpose is to transform random vectors with correlated non-normal marginals vecX into random vectors with uncorrelated standard normal marginals vecU. André Nataf introduced this transformation in 1962 (Nataf, 1962).","category":"page"},{"location":"IsoprobabilisticTransformations/NatafTransformation/","page":"Nataf Transformation","title":"Nataf Transformation","text":"The Nataf Transformation vecU = T^N(vecX) is composed of two transformations: ","category":"page"},{"location":"IsoprobabilisticTransformations/NatafTransformation/","page":"Nataf Transformation","title":"Nataf Transformation","text":"vecU = T^N(vecX) = (T_2^N circ T_1^N)(vecX)","category":"page"},{"location":"IsoprobabilisticTransformations/NatafTransformation/","page":"Nataf Transformation","title":"Nataf Transformation","text":"The first transformation vecZ = T_1^N(vecX) transforms random vector with correlated non-normal marginals vecX (with correlation matrix rho^X) into random vector with correlated standard normal marginals vecZ (with correlation matrix rho^Z). Here, Phi^-1(cdot) is the inverse of the cumulative density function of a standard normal random variable and F_X_i(cdot) is the cumulative density function of a marginalX_i.","category":"page"},{"location":"IsoprobabilisticTransformations/NatafTransformation/","page":"Nataf Transformation","title":"Nataf Transformation","text":"vecZ = T_1^N(vecX) = beginbmatrix Phi^-1(F_X_1(X_1))  vdots  Phi^-1(F_X_n(X_n)) endbmatrix ","category":"page"},{"location":"IsoprobabilisticTransformations/NatafTransformation/","page":"Nataf Transformation","title":"Nataf Transformation","text":"The second transformation vecU = T_2^N(vecZ) transforms random vector with correlated standard normal marginals vecZ into random vector with uncorrelated standard normal marginals vecU. Here, the matrix Gamma is used to decorrelate the standard normal marginals of random vector vecZ and can be chosen as any square-root matrix of the correlation matrix rho^Z. Fortuna.jl uses the Cholesky factor of the inverse of the correlation matrix (rho^Z)^-1 as the matrix Gamma.","category":"page"},{"location":"IsoprobabilisticTransformations/NatafTransformation/","page":"Nataf Transformation","title":"Nataf Transformation","text":"vecU = T_2^N(vecZ) = Gamma vecZ","category":"page"},{"location":"IsoprobabilisticTransformations/NatafTransformation/","page":"Nataf Transformation","title":"Nataf Transformation","text":"The first transformation vecZ = T_1^N(vecX) causes so-called correlation distortion. The correlation distortion causes the correlation coefficient between two standard normal marginals Z_i and Z_j, denoted by rho_ij^Z, to distort and differ from the original correlation coefficient between the corresponding non-normal marginals X_i and X_j, denoted by rho_ij^X, such that rho_ij^X neq rho_ij^Z. The relationship between the components of the correlation matrices rho_ij^X and rho_ij^X is given by","category":"page"},{"location":"IsoprobabilisticTransformations/NatafTransformation/","page":"Nataf Transformation","title":"Nataf Transformation","text":"rho_ij^X = dfrac1sigma_X_i sigma_X_j int_-infty^infty int_-infty^infty (F_X_i^-1(Phi(z_i)) - mu_X_i) (F_X_j^-1(Phi(z_j)) - mu_X_j) phi_2(z_i z_j rho_ij^Z) dz_i dz_j","category":"page"},{"location":"IsoprobabilisticTransformations/NatafTransformation/","page":"Nataf Transformation","title":"Nataf Transformation","text":"where phi_2(cdot) is the bivariate standard normal probability density function. Generally, this integral cannot be inverted analytically to solve for the coefficients of the correlation matrix rho^Z. In order to compute these coefficients, Fortuna.jl package (1) employs a two-dimensions Gauss-Legendre quadrature implemented in FastGaussQuadrature.jl package to expand the integral into  and (2) utilizes NonlinearSolve.jl package to find values of the coefficients of the correlation matrix rho^Z that satisfy the resulting expression.","category":"page"},{"location":"IsoprobabilisticTransformations/NatafTransformation/#API","page":"Nataf Transformation","title":"API","text":"","category":"section"},{"location":"IsoprobabilisticTransformations/NatafTransformation/","page":"Nataf Transformation","title":"Nataf Transformation","text":"NatafTransformation\ngetdistortedcorrelation(X::Vector{<:Distribution}, ρˣ::Matrix{<:Real})\ntransformsamples(Object::NatafTransformation, Samples::Union{Vector{<:Real},Matrix{<:Real}}, TransformationDirection::String)\ngetjacobian(Object::NatafTransformation, Samples::Union{Vector{<:Real},Matrix{<:Real}}, TransformationDirection::String)\njointpdf(Object::NatafTransformation, x::Union{Vector{<:Real},Matrix{<:Real}})","category":"page"},{"location":"IsoprobabilisticTransformations/NatafTransformation/#Fortuna.NatafTransformation","page":"Nataf Transformation","title":"Fortuna.NatafTransformation","text":"mutable struct NatafTransformation <: AbstractTransformation\n\nA custom type used by Fortuna.jl to perform the Nataf Transformation.\n\nX: Random vector with correlated non-normal marginal random variables\nρˣ: Correlation matrix of the random vector vecX\nρᶻ: Distorted correlation matrix the random vector vecZ\nL: Lower triangular matrix of the Cholesky decomposition of the distorted correlation matrix rho^Z\nL⁻¹: Inverse of the lower triangular matrix of the Cholesky decomposition of the distorted correlation matrix rho^Z\n\n\n\n\n\n","category":"type"},{"location":"IsoprobabilisticTransformations/NatafTransformation/#Fortuna.getdistortedcorrelation-Tuple{Vector{<:Distribution}, Matrix{<:Real}}","page":"Nataf Transformation","title":"Fortuna.getdistortedcorrelation","text":"getdistortedcorrelation(X::AbstractVector{<:Distribution}, ρˣ::AbstractMatrix{<:Real})\n\nThe function returns the distorted correlation matrix rho^Z of the correlated standard normal random variables vecZ. Additionally, the function returns the lower triangular matrix of the Cholesky decomposition of the distorted correlation matrix L and its inverse L^-1.\n\n\n\n\n\n","category":"method"},{"location":"IsoprobabilisticTransformations/NatafTransformation/#Fortuna.transformsamples-Tuple{NatafTransformation, Union{Matrix{<:Real}, Vector{<:Real}}, String}","page":"Nataf Transformation","title":"Fortuna.transformsamples","text":"transformsamples(Object::NatafTransformation, Samples::Union{AbstractVector, AbstractMatrix}, TransformationDirection::String)\n\nThe function transforms samples from X- to U-space and vice versa. \nIf `TransformationDirection is:\n\n\"X2U\", then the function transforms samples vecx from X- to U-space.\n\"U2X\", then the function transforms samples vecu from U- to X-space.\n\n\n\n\n\n","category":"method"},{"location":"IsoprobabilisticTransformations/NatafTransformation/#Fortuna.getjacobian-Tuple{NatafTransformation, Union{Matrix{<:Real}, Vector{<:Real}}, String}","page":"Nataf Transformation","title":"Fortuna.getjacobian","text":"getjacobian(Object::NatafTransformation, Samples::Union{AbstractVector{<:Real}, AbstractMatrix{<:Real}}, TransformationDirection::String)\n\nThe function returns the Jacobians of the transformations of samples from X- to U-space and vice versa. \nIf TransformationDirection is:\n\n\"X2U\", then the function returns the Jacobians of the transformations of samples vecx from X- to U-space.\n\"U2X\", then the function returns the Jacobians of the transformations of samples vecu from U- to X-space.\n\n\n\n\n\n","category":"method"},{"location":"IsoprobabilisticTransformations/NatafTransformation/#Fortuna.jointpdf-Tuple{NatafTransformation, Union{Matrix{<:Real}, Vector{<:Real}}}","page":"Nataf Transformation","title":"Fortuna.jointpdf","text":"jointpdf(Object::NatafTransformation, x::Union{AbstractVector{<:Real}, AbstractMatrix{<:Real}})\n\nThe function returns the values of the joint probability density functions f_vecX(vecx) evaluated at points vecx.\n\n\n\n\n\n","category":"method"},{"location":"IsoprobabilisticTransformations/RosenblattTransformation/","page":"Rosenblatt Transformation","title":"Rosenblatt Transformation","text":"warning: Warning\nThis feature is currently under development.","category":"page"},{"location":"IsoprobabilisticTransformations/RosenblattTransformation/#Rosenblatt-Transformation","page":"Rosenblatt Transformation","title":"Rosenblatt Transformation","text":"","category":"section"},{"location":"IsoprobabilisticTransformations/RosenblattTransformation/#Overview","page":"Rosenblatt Transformation","title":"Overview","text":"","category":"section"},{"location":"IsoprobabilisticTransformations/RosenblattTransformation/","page":"Rosenblatt Transformation","title":"Rosenblatt Transformation","text":"The Rosenblatt Transformation is another widely utilized isoprobabilistic transformation in structural reliability analysis. Similar to the Nataf Transformation, its purpose is to transform random vectors with correlated non-normal marginal random variables vecX into random vectors with uncorrelated standard normal marginal random variables vecU. Murray Rosenblatt introduced this transformation in 1952 (Rosenblatt, 1952).","category":"page"},{"location":"IsoprobabilisticTransformations/RosenblattTransformation/","page":"Rosenblatt Transformation","title":"Rosenblatt Transformation","text":"The Nataf Transformation vecU = T^R(vecX) is composed of two transformations: ","category":"page"},{"location":"IsoprobabilisticTransformations/RosenblattTransformation/","page":"Rosenblatt Transformation","title":"Rosenblatt Transformation","text":"vecU = T^R(vecX) = (T_2^R circ T_1^R)(vecX)","category":"page"},{"location":"IsoprobabilisticTransformations/RosenblattTransformation/","page":"Rosenblatt Transformation","title":"Rosenblatt Transformation","text":"The first transformation vecZ = T_1^R(vecX) transforms random vector with correlated non-normal marginal random variables vecX (with correlation matrix rho^X) into random vector with uncorrelated uniform marginal random variables vecZ.","category":"page"},{"location":"IsoprobabilisticTransformations/RosenblattTransformation/","page":"Rosenblatt Transformation","title":"Rosenblatt Transformation","text":"vecZ = T_1^R(vecX) = beginbmatrix F_X_1(X_1)  vdots  F_X_n  X_n - 1 dots X_1(X_n  X_n - 1 dots X_1) endbmatrix","category":"page"},{"location":"IsoprobabilisticTransformations/RosenblattTransformation/","page":"Rosenblatt Transformation","title":"Rosenblatt Transformation","text":"The second transformation vecU = T_2^R(vecZ) transforms random vector with uncorrelated uniform marginal random variables vecZ into random vector with uncorrelated standard normal marginal random variables vecU.","category":"page"},{"location":"IsoprobabilisticTransformations/RosenblattTransformation/","page":"Rosenblatt Transformation","title":"Rosenblatt Transformation","text":"vecU = T_2^R(vecZ) = beginbmatrix Phi^-1(Z_1)  vdots  Phi^-1(Z_n) endbmatrix","category":"page"},{"location":"IsoprobabilisticTransformations/RosenblattTransformation/#API","page":"Rosenblatt Transformation","title":"API","text":"","category":"section"},{"location":"IsoprobabilisticTransformations/RosenblattTransformation/","page":"Rosenblatt Transformation","title":"Rosenblatt Transformation","text":"RosenblattTransformation","category":"page"},{"location":"IsoprobabilisticTransformations/RosenblattTransformation/#Fortuna.RosenblattTransformation","page":"Rosenblatt Transformation","title":"Fortuna.RosenblattTransformation","text":"mutable struct RosenblattTransformation <: AbstractTransformation\n\nA custom type used by Fortuna.jl to perform the Rosenblatt Transformation.\n\n\n\n\n\n","category":"type"},{"location":"ReliabilityProblems/IS/#Importance-Sampling","page":"Importance Sampling","title":"Importance Sampling","text":"","category":"section"},{"location":"ReliabilityProblems/IS/#Overview","page":"Importance Sampling","title":"Overview","text":"","category":"section"},{"location":"ReliabilityProblems/IS/#API","page":"Importance Sampling","title":"API","text":"","category":"section"},{"location":"ReliabilityProblems/IS/","page":"Importance Sampling","title":"Importance Sampling","text":"IS\nanalyze(Problem::ReliabilityProblem, AnalysisMethod::IS)","category":"page"},{"location":"ReliabilityProblems/IS/#Fortuna.IS","page":"Importance Sampling","title":"Fortuna.IS","text":"struct IS <: AbstractReliabililyAnalysisMethod\n\nA custom type used by Fortuna.jl to perform reliability analysis using Importance Sampling technique.\n\nq: Proposal density function\nNumSamples: Number of samples\n\n\n\n\n\n","category":"type"},{"location":"ReliabilityProblems/IS/#Fortuna.analyze-Tuple{ReliabilityProblem, IS}","page":"Importance Sampling","title":"Fortuna.analyze","text":"analyze(Problem::ReliabilityProblem, AnalysisMethod::IS)\n\nThe function solves the provided reliability problem using Importance Sampling technique.\n\n\n\n\n\n","category":"method"},{"location":"Examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"using Fortuna\nusing Random\nRandom.seed!(1)","category":"page"},{"location":"Examples/#Isoprobabilistic-Transformation","page":"Examples","title":"Isoprobabilistic Transformation","text":"","category":"section"},{"location":"Examples/#Nataf-Transformation","page":"Examples","title":"Nataf Transformation","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"# Generate a random vector X with correlated marginal random variables X₁ and X₂:\nX₁  = generaterv(\"Gamma\", \"M\", [10, 1.5])\nX₂  = generaterv(\"Gumbel\", \"M\", [15, 2.5])\nX   = [X₁, X₂]\n\n# Define the correlation matrix:\nρˣ = [1 0.90; 0.90 1]\n\n# Perform the Nataf Transformation by defining a \"NatafTransformation\" object:\nNatafObject = NatafTransformation(X, ρˣ)\n\n# Generate 1000 samples of the random vector X in X-, Z-, and U-spaces:\nXSamples, USamples, ZSamples = samplerv(NatafObject, 1000, ITS())\n\nnothing # hide","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"<img src=\"../assets/NatafTransformation.svg\" class=\"center\" style=\"border-radius:5px;\"/>","category":"page"},{"location":"Examples/#Monte-Carlo-Simulations","page":"Examples","title":"Monte Carlo Simulations","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"# Generate a random vector X with correlated marginal random variables:\nM₁  = generaterv(\"Normal\", \"M\", [250, 250 * 0.3])\nM₂  = generaterv(\"Normal\", \"M\", [125, 125 * 0.3])\nP   = generaterv(\"Gumbel\", \"M\", [2500, 2500 * 0.2])\nY   = generaterv(\"Weibull\", \"M\", [40000, 40000 * 0.1])\nX   = [M₁, M₂, P, Y]\nρˣ  = [1 0.5 0.3 0; 0.5 1 0.3 0; 0.3 0.3 1 0; 0 0 0 1]\n\n# Define a limit state function:\na   = 0.190\ns₁  = 0.030\ns₂  = 0.015\ng(x) = 1 - x[1] / (s₁ * x[4]) - x[2] / (s₂ * x[4]) - (x[3] / (a * x[4])) ^ 2\n\n# Define a reliability problem:\nProblem = ReliabilityProblem(X, ρˣ, g)\n\n# Perform the reliability analysis using curve-fitting SORM:\nSolution = analyze(Problem, MCS())\nprintln(\"MCS:\")\nprintln(\"PoF: $(Solution.PoF)\")","category":"page"},{"location":"Examples/#First-Order-Reliability-Methods","page":"Examples","title":"First-Order Reliability Methods","text":"","category":"section"},{"location":"Examples/#Mean-Centered-First-Order-Second-Moment-Method","page":"Examples","title":"Mean-Centered First-Order Second-Moment Method","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"# Generate a random vector X with correlated marginal random variables:\nX₁  = generaterv(\"Normal\", \"Moments\", [10, 2])\nX₂  = generaterv(\"Normal\", \"Moments\", [20, 5])\nX   = [X₁, X₂]\nρˣ  = [1 0.5; 0.5 1]\n\n# Define two equivalent limit state functions:\ng₁(x) = x[1] ^ 2 - 2 * x[2]\ng₂(x) = 1 - 2 * x[2] / x[1] ^ 2\n\n# Define reliability problems:\nProblem₁ = ReliabilityProblem(X, ρˣ, g₁)\nProblem₂ = ReliabilityProblem(X, ρˣ, g₂)\n\n# Perform the reliability analysis:\nSolution₁ = analyze(Problem₁, FORM(MCFOSM()))\nSolution₂ = analyze(Problem₂, FORM(MCFOSM()))\nprintln(\"MCFOSM:\")\nprintln(\"β from g₁: $(Solution₁.β)\")\nprintln(\"β from g₂: $(Solution₂.β)\")","category":"page"},{"location":"Examples/#Improved-Hasofer-Lind-Rackwitz-Fiessler-Method","page":"Examples","title":"Improved Hasofer-Lind-Rackwitz-Fiessler Method","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"# Generate a random vector X with correlated marginal random variables:\nX₁  = generaterv(\"Normal\", \"Moments\", [10, 2])\nX₂  = generaterv(\"Normal\", \"Moments\", [20, 5])\nX   = [X₁, X₂]\nρˣ  = [1 0.5; 0.5 1]\n\n# Define two equivalent limit state functions:\ng₁(x) = x[1] ^ 2 - 2 * x[2]\ng₂(x) = 1 - 2 * x[2] / x[1] ^ 2\n\n# Define reliability problems:\nProblem₁ = ReliabilityProblem(X, ρˣ, g₁)\nProblem₂ = ReliabilityProblem(X, ρˣ, g₂)\n\n# Perform the reliability analysis:\nSolution₁ = analyze(Problem₁, FORM(iHLRF()))\nSolution₂ = analyze(Problem₂, FORM(iHLRF()))\nprintln(\"FORM:\")\nprintln(\"β from g₁: $(Solution₁.β)\")\nprintln(\"β from g₂: $(Solution₂.β)\")","category":"page"},{"location":"Examples/#Second-Order-Reliability-Methods","page":"Examples","title":"Second-Order Reliability Methods","text":"","category":"section"},{"location":"Examples/#Curve-Fitting-Method","page":"Examples","title":"Curve-Fitting Method","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"# Generate a random vector X with correlated marginal random variables:\nM₁  = generaterv(\"Normal\", \"M\", [250, 250 * 0.3])\nM₂  = generaterv(\"Normal\", \"M\", [125, 125 * 0.3])\nP   = generaterv(\"Gumbel\", \"M\", [2500, 2500 * 0.2])\nY   = generaterv(\"Weibull\", \"M\", [40000, 40000 * 0.1])\nX   = [M₁, M₂, P, Y]\nρˣ  = [1 0.5 0.3 0; 0.5 1 0.3 0; 0.3 0.3 1 0; 0 0 0 1]\n\n# Define a limit state function:\na   = 0.190\ns₁  = 0.030\ns₂  = 0.015\ng(x) = 1 - x[1] / (s₁ * x[4]) - x[2] / (s₂ * x[4]) - (x[3] / (a * x[4])) ^ 2\n\n# Define a reliability problem:\nProblem = ReliabilityProblem(X, ρˣ, g)\n\n# Perform the reliability analysis using curve-fitting SORM:\nSolution = analyze(Problem, SORM(CF()))\nprintln(\"SORM:\")\nprintln(\"β from FORM: $(Solution.β₁)\")\nprintln(\"β from SORM: $(Solution.β₂[1]) (Hohenbichler and Rackwitz)\")\nprintln(\"β from SORM: $(Solution.β₂[2]) (Breitung)\")\nprintln(\"PoF from FORM: $(Solution.PoF₁)\")\nprintln(\"PoF from SORM: $(Solution.PoF₂[1]) (Hohenbichler and Rackwitz)\")\nprintln(\"PoF from SORM: $(Solution.PoF₂[2]) (Breitung)\")","category":"page"},{"location":"Examples/#Point-Fitting-Method","page":"Examples","title":"Point-Fitting Method","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"# Generate a random vector X with correlated marginal random variables:\nM₁  = generaterv(\"Normal\", \"M\", [250, 250 * 0.3])\nM₂  = generaterv(\"Normal\", \"M\", [125, 125 * 0.3])\nP   = generaterv(\"Gumbel\", \"M\", [2500, 2500 * 0.2])\nY   = generaterv(\"Weibull\", \"M\", [40000, 40000 * 0.1])\nX   = [M₁, M₂, P, Y]\nρˣ  = [1 0.5 0.3 0; 0.5 1 0.3 0; 0.3 0.3 1 0; 0 0 0 1]\n\n# Define a limit state function:\na   = 0.190\ns₁  = 0.030\ns₂  = 0.015\ng(x) = 1 - x[1] / (s₁ * x[4]) - x[2] / (s₂ * x[4]) - (x[3] / (a * x[4])) ^ 2\n\n# Define a reliability problem:\nProblem = ReliabilityProblem(X, ρˣ, g)\n\n# Perform the reliability analysis using curve-fitting SORM:\nSolution = analyze(Problem, SORM(PF()))\nprintln(\"SORM:\")\nprintln(\"β from FORM: $(Solution.β₁)\")\nprintln(\"β from SORM: $(Solution.β₂[1]) (Hohenbichler and Rackwitz)\")\nprintln(\"β from SORM: $(Solution.β₂[2]) (Breitung)\")\nprintln(\"PoF from FORM: $(Solution.PoF₁)\")\nprintln(\"PoF from SORM: $(Solution.PoF₂[1]) (Hohenbichler and Rackwitz)\")\nprintln(\"PoF from SORM: $(Solution.PoF₂[2]) (Breitung)\")","category":"page"},{"location":"Examples/#Subset-Simulation-Method","page":"Examples","title":"Subset Simulation Method","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"# Define a random vector of uncorrelated marginal distributions:\nX₁  = generaterv(\"Exponential\", \"P\", 1)\nX₂  = generaterv(\"Exponential\", \"P\", 1)\nX   = [X₁, X₂]\nρˣ  = [1 0; 0 1]\n\n# Define a limit state function:\ng(x) = 10 - x[1] - x[2]\n\n# Define reliability problems:\nProblem = ReliabilityProblem(X, ρˣ, g)\n\n# Perform the reliability analysis using SSM:\nSolution = analyze(Problem, SSM())\nprintln(\"SSM\")\nprintln(\"PoF from SSM: $(Solution.PoF)\")","category":"page"},{"location":"RandomVariables/SampleRV/#Sampling-Random-Variables","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"","category":"section"},{"location":"RandomVariables/SampleRV/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"Fortuna.jl package allows to easily generate samples of both uncorrelated and correlated random variables using samplerv() function using different sampling techniques. Current version of the package implements Inverse Transform Sampling (ITS) and Latin Hypercube Sampling (LHS) techniques.","category":"page"},{"location":"RandomVariables/SampleRV/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"using Fortuna\nusing Random\nRandom.seed!(1)","category":"page"},{"location":"RandomVariables/SampleRV/#Sampling-Random-Variables-2","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"","category":"section"},{"location":"RandomVariables/SampleRV/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"To generate samples of a random variable:","category":"page"},{"location":"RandomVariables/SampleRV/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"Generate a random variable (X).","category":"page"},{"location":"RandomVariables/SampleRV/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"X = generaterv(\"Gamma\", \"M\", [10, 1.5])\n\nnothing # hide","category":"page"},{"location":"RandomVariables/SampleRV/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"Sample the generated random variable using a sampling technique of your choice.","category":"page"},{"location":"RandomVariables/SampleRV/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"XSamples = samplerv(X, 5000, ITS())\n\nnothing # hide","category":"page"},{"location":"RandomVariables/SampleRV/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"<img src=\"../Sample-RVariable.svg\" class=\"center\" style=\"max-height:400px; border-radius:2.5px;\"/>","category":"page"},{"location":"RandomVariables/SampleRV/#Sampling-Random-Vectors-with-Uncorrelated-Marginals","page":"Sampling Random Variables","title":"Sampling Random Vectors with Uncorrelated Marginals","text":"","category":"section"},{"location":"RandomVariables/SampleRV/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"To generate samples of a random vector with uncorrelated marginals:","category":"page"},{"location":"RandomVariables/SampleRV/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"Generate random variables (X₁ and X₂).\nDefine a random vector (X) with the generated random variables as marginals.","category":"page"},{"location":"RandomVariables/SampleRV/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"# Generate a random vector X with uncorrelated marginals X₁ and X₂:\nX₁  = generaterv(\"Gamma\", \"M\", [10, 1.5])\nX₂  = generaterv(\"Gumbel\", \"M\", [15, 2.5])\nX   = [X₁, X₂]\n\nnothing # hide","category":"page"},{"location":"RandomVariables/SampleRV/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"Sample the defined random vector using a sampling technique of your choice.","category":"page"},{"location":"RandomVariables/SampleRV/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"# Generate 5000 samples of the random vector X using Inverse Transform Sampling technique:\nXSamples = samplerv(X, 5000, ITS())\n\nnothing # hide","category":"page"},{"location":"RandomVariables/SampleRV/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"<img src=\"../Sample-RVector-U.svg\" class=\"center\" style=\"max-height:400px; border-radius:2.5px;\"/>","category":"page"},{"location":"RandomVariables/SampleRV/#Sampling-Random-Vectors-with-Correlated-Marginals","page":"Sampling Random Variables","title":"Sampling Random Vectors with Correlated Marginals","text":"","category":"section"},{"location":"RandomVariables/SampleRV/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"To generate samples of a random vector with correlated marginals:","category":"page"},{"location":"RandomVariables/SampleRV/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"Generate random variables (X₁ and X₂).\nDefine a random vector (X) with the generated random variables as marginals.","category":"page"},{"location":"RandomVariables/SampleRV/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"# Define a random vector X with correlated marginals X₁ and X₂:\nX₁  = generaterv(\"Gamma\", \"M\", [10, 1.5])\nX₂  = generaterv(\"Gumbel\", \"M\", [15, 2.5])\nX   = [X₁, X₂]\n\nnothing # hide","category":"page"},{"location":"RandomVariables/SampleRV/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"Define a correlated matrix (ρˣ) for the defined random vector.\nDefine a transformation object that hold all information about the define random vector.","category":"page"},{"location":"RandomVariables/SampleRV/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"# Define a correlation matrix:\nρˣ = [1 0.90; 0.90 1]\n\n# Define a transformation object:\nTransformationObject = NatafTransformation(X, ρˣ)\n\nnothing # hide","category":"page"},{"location":"RandomVariables/SampleRV/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"Sample the defined random vector using a sampling technique of your choice.","category":"page"},{"location":"RandomVariables/SampleRV/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"# Generate 5000 samples of the random vector X in X-, Z-, and U-spaces using Inverse Transform Sampling technique:\nXSamples, ZSamples, USamples = samplerv(TransformationObject, 5000, ITS())\n\nnothing # hide","category":"page"},{"location":"RandomVariables/SampleRV/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"<img src=\"../Sample-RVector-C.svg\" class=\"center\" style=\"max-height:400px; border-radius:2.5px;\"/>","category":"page"},{"location":"RandomVariables/SampleRV/#API","page":"Sampling Random Variables","title":"API","text":"","category":"section"},{"location":"RandomVariables/SampleRV/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"ITS\nLHS\nsamplerv(Samplers::Union{<:Distribution, Vector{<:Distribution}}, NumSamples::Integer, SamplingTechnique::AbstractSamplingTechnique)\nsamplerv(Object::NatafTransformation, NumSamples::Integer, SamplingTechnique::AbstractSamplingTechnique)","category":"page"},{"location":"RandomVariables/SampleRV/#Fortuna.ITS","page":"Sampling Random Variables","title":"Fortuna.ITS","text":"struct ITS <: AbstractSamplingTechnique\n\nA custom type used by Fortuna.jl to perform the Inverse Transform Sampling.\n\n\n\n\n\n","category":"type"},{"location":"RandomVariables/SampleRV/#Fortuna.LHS","page":"Sampling Random Variables","title":"Fortuna.LHS","text":"struct LHS <: AbstractSamplingTechnique\n\nA custom type used by Fortuna.jl to perform the Latin Hypercube Sampling.\n\n\n\n\n\n","category":"type"},{"location":"RandomVariables/SampleRV/#Fortuna.samplerv-Tuple{Union{Distribution, Vector{<:Distribution}}, Integer, AbstractSamplingTechnique}","page":"Sampling Random Variables","title":"Fortuna.samplerv","text":"Samples = samplerv(Samplers::Union{<:Distribution, Vector{<:Distribution}}, NumSamples::Integer, SamplingTechnique::AbstractSamplingTechnique)\n\nThe function returns samples of random variables and random vectors with uncorrelated marginal random variables using various sampling techniques. \nIf `SamplingTechnique is:\n\nITS() samples are generated using Inverse Transform Sampling technique.\nLHS() samples are generated using Latin Hypercube Sampling technique.\n\n\n\n\n\n","category":"method"},{"location":"RandomVariables/SampleRV/#Fortuna.samplerv-Tuple{NatafTransformation, Integer, AbstractSamplingTechnique}","page":"Sampling Random Variables","title":"Fortuna.samplerv","text":"XSamples, ZSamples, USamples = samplerv(Object::NatafTransformation, NumSamples::Integer, SamplingTechnique::AbstractSamplingTechnique)\n\nThis function generates samples of random variables in X-, Z-, and U-spaces using a NatafTransformation object.\n\nX-space - space of correlated non-normal random variables\nZ-space - space of correlated standard normal random variables\nU-space - space of uncorrelated standard normal random variables\n\n\n\n\n\n","category":"method"},{"location":"InverseReliabilityProblems/","page":"Inverse Reliability Problems","title":"Inverse Reliability Problems","text":"warning: Warning\nThis feature is currently under development.","category":"page"},{"location":"InverseReliabilityProblems/#Inverse-Reliability-Problems","page":"Inverse Reliability Problems","title":"Inverse Reliability Problems","text":"","category":"section"},{"location":"RandomVariables/GenerateRV/#Generating-Random-Variables","page":"Generating Random Variables","title":"Generating Random Variables","text":"","category":"section"},{"location":"RandomVariables/GenerateRV/","page":"Generating Random Variables","title":"Generating Random Variables","text":"Fortuna.jl package builds its capacity to generate random variables using generaterv() function by utilizing the widely-adopted Distributions.jl package, enabling seamless integration with other probabilistic programming Julia packages such as Turing.jl and RxInfer.jl. However, unlike Distributions.jl package, Fortuna.jl allows you to generate random variables not only using their parameters, but also using their moments, which often useful in the field of Structural and System Reliability Analysis.","category":"page"},{"location":"RandomVariables/GenerateRV/","page":"Generating Random Variables","title":"Generating Random Variables","text":"using Fortuna","category":"page"},{"location":"RandomVariables/GenerateRV/#Generating-Random-Variables-Using-Moments","page":"Generating Random Variables","title":"Generating Random Variables Using Moments","text":"","category":"section"},{"location":"RandomVariables/GenerateRV/","page":"Generating Random Variables","title":"Generating Random Variables","text":"To generate a random variable using its moments use pass \"M\" or \"Moments\" as the second argument of generaterv() function followed by the moments themselves. ","category":"page"},{"location":"RandomVariables/GenerateRV/","page":"Generating Random Variables","title":"Generating Random Variables","text":"# Generate a lognormally distributed random variable R \n# with mean (μ) of 15 and standard deviation (σ) of 10:\nR = generaterv(\"LogNormal\", \"M\", [15, 10])\nprintln(\"μ = $(mean(R))\")\nprintln(\"σ = $(std(R))\")","category":"page"},{"location":"RandomVariables/GenerateRV/#Generating-Random-Variables-Using-Parameters","page":"Generating Random Variables","title":"Generating Random Variables Using Parameters","text":"","category":"section"},{"location":"RandomVariables/GenerateRV/","page":"Generating Random Variables","title":"Generating Random Variables","text":"To generate a random variable using its parameters use pass \"P\" or \"Parameters\" as the second argument of generaterv() function followed by the parameters themselves. ","category":"page"},{"location":"RandomVariables/GenerateRV/","page":"Generating Random Variables","title":"Generating Random Variables","text":"# Generate a gamma-distributed random variable Q \n# with shape parameter (α) of 16 and scale parameter (θ) of 0.625:\nQ = generaterv(\"Gamma\", \"P\", [16, 0.625])\nprintln(\"α = $(params(Q)[1])\")\nprintln(\"θ = $(params(Q)[2])\")","category":"page"},{"location":"RandomVariables/GenerateRV/#Supported-Random-Variables","page":"Generating Random Variables","title":"Supported Random Variables","text":"","category":"section"},{"location":"RandomVariables/GenerateRV/","page":"Generating Random Variables","title":"Generating Random Variables","text":"note: Note\nIf you want to define a random variable that is not supported by Fortuna.jl package, please raise an issue on the Github Issues page.","category":"page"},{"location":"RandomVariables/GenerateRV/","page":"Generating Random Variables","title":"Generating Random Variables","text":"Fortuna.jl package currently supports the following distributions:","category":"page"},{"location":"RandomVariables/GenerateRV/","page":"Generating Random Variables","title":"Generating Random Variables","text":"Exponential\nGamma\nGumbel\nLogNormal\nNormal\nPoisson\nUniform\nWeibull","category":"page"},{"location":"RandomVariables/GenerateRV/#API","page":"Generating Random Variables","title":"API","text":"","category":"section"},{"location":"RandomVariables/GenerateRV/","page":"Generating Random Variables","title":"Generating Random Variables","text":"generaterv(DistributionName::String, DefineBy::String, Values::Union{Real, Vector{<:Real}})","category":"page"},{"location":"RandomVariables/GenerateRV/#Fortuna.generaterv-Tuple{String, String, Union{Real, Vector{<:Real}}}","page":"Generating Random Variables","title":"Fortuna.generaterv","text":"generaterv(DistributionName::String, DefineBy::String, Values::Union{Real, Vector{<:Real}})\n\nThe function generates random variables given the distribution name and either its moments or parameters. \nIf DefineBy is:\n\n\"M\" or \"Moments\", then moments of a random variable must be provided in Values.\n\"P\" or \"Parameters\", then parameters of a random variable must be provided in Values.\n\n\n\n\n\n","category":"method"},{"location":"References/#References","page":"References","title":"References","text":"","category":"section"},{"location":"References/","page":"References","title":"References","text":"Breitung, K. (1984). Asymptotic Approximations for Multinormal Integrals. Journal of Engineering Mechanics 110, 357–366.\n\n\n\nHohenbichler, M. and Rackwitz, R. (1988). Improvement Of Second‐Order Reliability Estimates by Importance Sampling. Journal of Engineering Mechanics 114, 2195–2199.\n\n\n\nNataf, A. (1962). Détermination des Distribution dont les Marges sont Données. Comptes Rendus de l'Académie des Sciences 225, 42–43.\n\n\n\nRosenblatt, M. (1952). Remarks on a Multivariate Transformation. The Annals of Mathematical Statistics 23, 470–472.\n\n\n\nTvedt, L. (1990). Distribution of Quadratic Forms in Normal Space—Application to Structural Reliability. Journal of Engineering Mechanics 116, 1183–1197.\n\n\n\n","category":"page"},{"location":"ReliabilityProblems/MCS/#Monte-Carlo-Simulations","page":"Monte Carlo Simulations","title":"Monte Carlo Simulations","text":"","category":"section"},{"location":"ReliabilityProblems/MCS/#Overview","page":"Monte Carlo Simulations","title":"Overview","text":"","category":"section"},{"location":"ReliabilityProblems/MCS/","page":"Monte Carlo Simulations","title":"Monte Carlo Simulations","text":"Using brute force Monte Carlo simulations (MCS) is the simplest way to estimate the probability of failure P_f for reliability problems with both simple and complex limit state functions g(vecX). The brute force MCS relies on the following reformulation of the general analytical expression for the probability of failure P_f:","category":"page"},{"location":"ReliabilityProblems/MCS/","page":"Monte Carlo Simulations","title":"Monte Carlo Simulations","text":"P_f = P(Omega_f) = int_Omega_f f_vecX(vecx) dvecx = int_mathbbR^n mathbbI(vecx) f_vecX(vecx) dvecx = mathbbEmathbbI(vecx)","category":"page"},{"location":"ReliabilityProblems/MCS/","page":"Monte Carlo Simulations","title":"Monte Carlo Simulations","text":"where f_vecX(vecx) is the joint probability function of the input random vector vecX, Omega_f = vecX g(vecX) leq 0 is the failure domain defined by the limit state function g(vecX), and mathbbI(vecx) is the indicator function given by:","category":"page"},{"location":"ReliabilityProblems/MCS/","page":"Monte Carlo Simulations","title":"Monte Carlo Simulations","text":"mathbbI(vecx) = \nbegincases\n    1  textif  vecx in Omega_f \n    0  textotherwise\nendcases","category":"page"},{"location":"ReliabilityProblems/MCS/","page":"Monte Carlo Simulations","title":"Monte Carlo Simulations","text":"Hence, the probability of failure P_f is defined as the expectation of the indicator function mathbbI(vecx). If samples of the input random vector vecx are generated numerically, then the estimator of the probability of failure hatP_f is","category":"page"},{"location":"ReliabilityProblems/MCS/","page":"Monte Carlo Simulations","title":"Monte Carlo Simulations","text":"hatP_f = dfrac1N sum_i = 1^N mathbbI(vecx_i)","category":"page"},{"location":"ReliabilityProblems/MCS/","page":"Monte Carlo Simulations","title":"Monte Carlo Simulations","text":"where N is the number of generated sampled. The estimator hatP_f is unbiased, i.e., it correctly predicts the true probability of failure, such that  mathbbE(hatP_f) = P_f. The main drawback of using the MCS is that is becomes prohibitively expensive to use if the true probability is too small, e.g., P_f lessapprox 10^-6, given that the variance of the estimator is inversely proportional to the number of generated samples, such that,","category":"page"},{"location":"ReliabilityProblems/MCS/","page":"Monte Carlo Simulations","title":"Monte Carlo Simulations","text":"textVar(hatP_f) = frac1N P_f (1 - P_f)","category":"page"},{"location":"ReliabilityProblems/MCS/","page":"Monte Carlo Simulations","title":"Monte Carlo Simulations","text":"tip: Tip\nFor typical structural reliability problems with true probabilities of failure P_f of approx 10^-3, it is recommended to use N = 10^6 samples to get the coefficient of variation of the estimator V_P_f of approx 010.<img src=\"../RecommendedN.svg\" class=\"center\" style=\"height:350px; border-radius:5px;\"/>","category":"page"},{"location":"ReliabilityProblems/MCS/#API","page":"Monte Carlo Simulations","title":"API","text":"","category":"section"},{"location":"ReliabilityProblems/MCS/","page":"Monte Carlo Simulations","title":"Monte Carlo Simulations","text":"MCS\nanalyze(Problem::ReliabilityProblem, AnalysisMethod::MCS)","category":"page"},{"location":"ReliabilityProblems/MCS/#Fortuna.MCS","page":"Monte Carlo Simulations","title":"Fortuna.MCS","text":"struct MCS <: AbstractReliabililyAnalysisMethod\n\nA custom type used by Fortuna.jl to perform reliability analysis using Monte Carlo simulations.\n\nNumSamples: Number of samples\nSamplingTechnique: Sampling technique used to generate samples\n\n\n\n\n\n","category":"type"},{"location":"ReliabilityProblems/MCS/#Fortuna.analyze-Tuple{ReliabilityProblem, MCS}","page":"Monte Carlo Simulations","title":"Fortuna.analyze","text":"analyze(Problem::ReliabilityProblem, AnalysisMethod::MCS)\n\nThe function solves the provided reliability problem using Monte Carlo simulations.\n\n\n\n\n\n","category":"method"},{"location":"ReliabilityProblems/FORM/#FORMPage","page":"First-Order Reliability Methods","title":"First-Order Reliability Methods","text":"","category":"section"},{"location":"ReliabilityProblems/FORM/#Mean-Centered-First-Order-Second-Moment-Method","page":"First-Order Reliability Methods","title":"Mean-Centered First-Order Second-Moment Method","text":"","category":"section"},{"location":"ReliabilityProblems/FORM/","page":"First-Order Reliability Methods","title":"First-Order Reliability Methods","text":"The MCFOSM method is the simplest and least computationally expensive type of reliability method. It utilizes the first-order Taylor expansion of the limit state function g(vecX) at the mean values and the first two moments of the marginal random variables involved in the reliability problem to evaluate the reliability index. However, despite the fact that it is simple and does not require the complete knowledge of the random variables involved in the reliability problem, the MCFOSM method faces an issue known as the invariance problem. This problem arises because the resulting reliability index beta is dependent on the formulation of the limit state function g(vecX). In other words, two equivalent limit state functions with the same failure boundaries produce two different reliability indices; thus, the use of MCFOSM method is not recommended.","category":"page"},{"location":"ReliabilityProblems/FORM/#Rackwitz-Fiessler-Method","page":"First-Order Reliability Methods","title":"Rackwitz-Fiessler Method","text":"","category":"section"},{"location":"ReliabilityProblems/FORM/","page":"First-Order Reliability Methods","title":"First-Order Reliability Methods","text":"warning: Warning\nThis feature is currently under development.","category":"page"},{"location":"ReliabilityProblems/FORM/#Plain-and-Improved-Hasofer-Lind-Rackwitz-Fiessler-Method","page":"First-Order Reliability Methods","title":"Plain and Improved Hasofer-Lind-Rackwitz-Fiessler Method","text":"","category":"section"},{"location":"ReliabilityProblems/FORM/","page":"First-Order Reliability Methods","title":"First-Order Reliability Methods","text":"The HLRF method overcomes the invariance problem faced by the MCFOSM method by using the first-order Taylor expansion of the limit state function at a point known as the design point vecx^* that lies on the failure boundary given by g(vecX) = 0. Since the design point is not known a priori, the HLRF method is inherently an iterative method. Fortuna.jl implements two versions of HLRF method: plain HLRF method where the step size in the negative gradient descent is always set to unity and improved HLRF (iHLRF) method where the step size is determined using a line search algorithm.","category":"page"},{"location":"ReliabilityProblems/FORM/#API","page":"First-Order Reliability Methods","title":"API","text":"","category":"section"},{"location":"ReliabilityProblems/FORM/","page":"First-Order Reliability Methods","title":"First-Order Reliability Methods","text":"FORM\nFORMSubmethod\nanalyze(Problem::ReliabilityProblem, AnalysisMethod::FORM)","category":"page"},{"location":"ReliabilityProblems/FORM/#Fortuna.FORM","page":"First-Order Reliability Methods","title":"Fortuna.FORM","text":"struct FORM <: AbstractReliabililyAnalysisMethod\n\nA custom type used by Fortuna.jl to perform reliability analysis using First-Order Reliability Methods.\n\nSubmethod: Analysis method that falls under the category of First-Order Reliability Methods.\n\n\n\n\n\n","category":"type"},{"location":"ReliabilityProblems/FORM/#Fortuna.FORMSubmethod","page":"First-Order Reliability Methods","title":"Fortuna.FORMSubmethod","text":"abstract type FORMSubmethod end\n\nA custom abstract supertype used by Fortuna.jl to define various types of First-Order Reliability Methods.\n\n\n\n\n\n","category":"type"},{"location":"ReliabilityProblems/FORM/#Fortuna.analyze-Tuple{ReliabilityProblem, FORM}","page":"First-Order Reliability Methods","title":"Fortuna.analyze","text":"analyze(Problem::ReliabilityProblem, AnalysisMethod::FORM)\n\nThe function solves the provided reliability problem using any submethod that falls under a broader category of First-Order Reliability Methods (FORM).\n\n\n\n\n\n","category":"method"},{"location":"ReliabilityProblems/SSM/","page":"Subset Simulation Method","title":"Subset Simulation Method","text":"warning: Warning\nThis feature is experimental and not well-tested.","category":"page"},{"location":"ReliabilityProblems/SSM/#Subset-Simulation-Method","page":"Subset Simulation Method","title":"Subset Simulation Method","text":"","category":"section"},{"location":"ReliabilityProblems/SSM/#Overview","page":"Subset Simulation Method","title":"Overview","text":"","category":"section"},{"location":"ReliabilityProblems/SSM/","page":"Subset Simulation Method","title":"Subset Simulation Method","text":"The Subset Simulation method (SSM) is a robust simulation technique that transforms a rare event into a sequence of multiple intermediate failure events with larger probabilities and efficiently approximates the probability of the mentioned rare event. That is, the failure event Omega_f = vecX g(vecX) leq 0 is expressed as a union of M nested intermediate events Omega_f_1, dots, Omega_f_M, such that Omega_f_M subset dots subset Omega_f_1 and Omega_f = cap_i = 1^M Omega_f_i. The intermediate failure events are defined as Omega_f_i = vecX g(vecX) leq b_i, where b_1  dots  b_M = 0 are non-negative thresholds selected such that each conditional probability P(Omega_f_i + 1  Omega_f_i) equals a target conditional probability P_0.","category":"page"},{"location":"ReliabilityProblems/SSM/","page":"Subset Simulation Method","title":"Subset Simulation Method","text":"P_f = P(Omega_f) = P(cap_i = 1^M Omega_f_i) = P(Omega_f_1) prod_i = 1^M - 1 P(Omega_f_i + 1  Omega_f_i)","category":"page"},{"location":"ReliabilityProblems/SSM/","page":"Subset Simulation Method","title":"Subset Simulation Method","text":"The threshold for the first failure event b_1 is computed using the Monte Carlo simulations. The thresholds for the following intermediate failure events b_i are computed using the Monte Carlo Markov Chain samples generated from the conditional probability density functions f_vecX(vecx  Omega_f_i).","category":"page"},{"location":"ReliabilityProblems/SSM/#API","page":"Subset Simulation Method","title":"API","text":"","category":"section"},{"location":"ReliabilityProblems/SSM/","page":"Subset Simulation Method","title":"Subset Simulation Method","text":"SSM\nSSMCache\nanalyze(Problem::ReliabilityProblem, AnalysisMethod::SSM)","category":"page"},{"location":"ReliabilityProblems/SSM/#Fortuna.SSM","page":"Subset Simulation Method","title":"Fortuna.SSM","text":"struct SSM <: AbstractReliabililyAnalysisMethod\n\nA custom type used by Fortuna.jl to perform the Subset Siumlation Method.\n\nP₀: Target conditional probability\nNumSamples: Number of samples to generate for each subset\nMaxNumSubsets: Maximum number of subsets\n\n\n\n\n\n","category":"type"},{"location":"ReliabilityProblems/SSM/#Fortuna.SSMCache","page":"Subset Simulation Method","title":"Fortuna.SSMCache","text":"struct SSMCache\n\nA custom type used by Fortuna.jl to store the results of the analysis performed using the Subset Siumlation Method.\n\nXSamplesSubset: Samples generated within each subset in X-space\nUSamplesSubset: Samples generated within each subset in U-space\nCSubset: Thresholds for each subset\nPoFSubset: Probabilities of failure for each subset\nPoF: Probabilities of failure\n\n\n\n\n\n","category":"type"},{"location":"ReliabilityProblems/SSM/#Fortuna.analyze-Tuple{ReliabilityProblem, SSM}","page":"Subset Simulation Method","title":"Fortuna.analyze","text":"analyze(Problem::ReliabilityProblem, AnalysisMethod::SSM)\n\nThe function solves the provided reliability problem using the Subset Simulation Method (SSM).\n\n\n\n\n\n","category":"method"},{"location":"Showcases/#Showcases","page":"Showcases","title":"Showcases","text":"","category":"section"},{"location":"Showcases/","page":"Showcases","title":"Showcases","text":"A comprehensive list of all academic publications that have used Fortuna.jl:","category":"page"},{"location":"Showcases/","page":"Showcases","title":"Showcases","text":"Akchurin, D.; Sabelli, R.; Ziemian, R. D. and Schafer, B. W. (2024). ASD and LRFD: Reliability Comparison for Designs Subjected to Wind Loads. Journal of Constructional Steel Research 213, 108327.\n\n\n\n","category":"page"},{"location":"ReliabilityProblems/DefiningReliabilityProblems/#Defining-Reliability-Problems","page":"Defining Reliability Problems","title":"Defining Reliability Problems","text":"","category":"section"},{"location":"ReliabilityProblems/DefiningReliabilityProblems/#Overview","page":"Defining Reliability Problems","title":"Overview","text":"","category":"section"},{"location":"ReliabilityProblems/DefiningReliabilityProblems/","page":"Defining Reliability Problems","title":"Defining Reliability Problems","text":"In generally, 3 main \"items\" are always need to fully define a reliability problem and successfully analyze it to find the associated probability of failure P_f and reliability index beta:","category":"page"},{"location":"ReliabilityProblems/DefiningReliabilityProblems/","page":"Defining Reliability Problems","title":"Defining Reliability Problems","text":"vecX - Random vector with correlated non-normal marginals\nrho^X - Correlation matrix\ng(vecX) - Limit state function","category":"page"},{"location":"ReliabilityProblems/DefiningReliabilityProblems/","page":"Defining Reliability Problems","title":"Defining Reliability Problems","text":"Fortuna.jl package uses these 3 \"items\" to fully define reliability problems using a custom ReliabilityProblem() type as shown in the example below.","category":"page"},{"location":"ReliabilityProblems/DefiningReliabilityProblems/","page":"Defining Reliability Problems","title":"Defining Reliability Problems","text":"using Fortuna","category":"page"},{"location":"ReliabilityProblems/DefiningReliabilityProblems/","page":"Defining Reliability Problems","title":"Defining Reliability Problems","text":"# Generate a random vector X with correlated marginal random variables X₁ and X₂:\nX₁  = generaterv(\"Normal\", \"Moments\", [10, 2])\nX₂  = generaterv(\"Normal\", \"Moments\", [20, 5])\nX   = [X₁, X₂]\n\n# Define a correlation matrix for the random vector X:\nρˣ = [1 0.5; 0.5 1]\n\n# Define a limit state function:\ng(x) = x[1]^2 - 2 * x[2]\n\n# Define a reliability problem using the provided information:\nProblem = ReliabilityProblem(X, ρˣ, g)\n\nnothing # hide","category":"page"},{"location":"ReliabilityProblems/DefiningReliabilityProblems/","page":"Defining Reliability Problems","title":"Defining Reliability Problems","text":"note: Note\nThe definition of the limit state function g(vecX) in Fortuna.jl package only pertains to its form (e.g., whether it is linear, square, exponential, etc. in each variable). The information about the random variables involved in the reliability problem is carried in the random vector vecX and its correlation matrix rho^X, that you use when defining a reliability problem using a custom ReliabilityProblem() type.","category":"page"},{"location":"ReliabilityProblems/DefiningReliabilityProblems/#Analyzing-Reliability-Problems","page":"Defining Reliability Problems","title":"Analyzing Reliability Problems","text":"","category":"section"},{"location":"ReliabilityProblems/DefiningReliabilityProblems/","page":"Defining Reliability Problems","title":"Defining Reliability Problems","text":"After defining the reliability problem, Fortuna.jl allows to easily solve it using a whole suite of First- and Second-Order Reliability Methods through a single analyze() function as shown in the example below.","category":"page"},{"location":"ReliabilityProblems/DefiningReliabilityProblems/","page":"Defining Reliability Problems","title":"Defining Reliability Problems","text":"# Solve the reliability problem using an imporved Hasofer-Lind-Rackwitz-Fiessler method:\nSolution = analyze(Problem, FORM(iHLRF()))\nprintln(\"PoF = $(Solution.PoF)\")\nprintln(\"β = $(Solution.β)\")","category":"page"},{"location":"ReliabilityProblems/DefiningReliabilityProblems/","page":"Defining Reliability Problems","title":"Defining Reliability Problems","text":"Descriptions of all First- and Second-Order Reliability Methods implemented in Fortuna.jl can be found on First-Order Reliability Methods and Second-Order Reliability Methods pages.","category":"page"},{"location":"ReliabilityProblems/DefiningReliabilityProblems/#API","page":"Defining Reliability Problems","title":"API","text":"","category":"section"},{"location":"ReliabilityProblems/DefiningReliabilityProblems/","page":"Defining Reliability Problems","title":"Defining Reliability Problems","text":"ReliabilityProblem","category":"page"},{"location":"ReliabilityProblems/DefiningReliabilityProblems/#Fortuna.ReliabilityProblem","page":"Defining Reliability Problems","title":"Fortuna.ReliabilityProblem","text":"mutable struct ReliabilityProblem <: AbstractReliabilityProblem\n\nA custom type used by Fortuna.jl to define reliability problems.\n\nX: Random vector with correlated non-normal marginal random variables\nρˣ: Correlation matrix\ng: Limit state function\n\n\n\n\n\n","category":"type"},{"location":"SensitivityAnalysis/","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"warning: Warning\nThis feature is currently under development.","category":"page"},{"location":"SensitivityAnalysis/#Sensitivity-Analysis","page":"Sensitivity Analysis","title":"Sensitivity Analysis","text":"","category":"section"},{"location":"ReliabilityProblems/SORM/#SORMPage","page":"Second-Order Reliability Methods","title":"Second-Order Reliability Methods","text":"","category":"section"},{"location":"ReliabilityProblems/SORM/","page":"Second-Order Reliability Methods","title":"Second-Order Reliability Methods","text":"The SORM is an improvement over the FORM by accounting for the curved nature of the failure boundary given by g(vecX) = 0 around the design point vecx^*; thus, providing a better approximation of the probability of failure P_f.","category":"page"},{"location":"ReliabilityProblems/SORM/#Curve-Fitting-Method","page":"Second-Order Reliability Methods","title":"Curve-Fitting Method","text":"","category":"section"},{"location":"ReliabilityProblems/SORM/","page":"Second-Order Reliability Methods","title":"Second-Order Reliability Methods","text":"Fortuna.jl package implements the CF method that fits a hyper-paraboloid surface with a vertex at the design point vecx^* and the principal curvatures matching the principal curvatures of the failure boundary  given by g(vecX) = 0 at that point. The probabilities P_f of failure are estimated using Hohenbichler and Rackwitz (1988) and Breitung (1984) approximations of the exact solution provided by Tvedt (1990). The calculated probabilities of failure P_f are then used to estimate the generalized reliability indices beta, which account for the curved nature of the failure boundary given by g(vecX) = 0 around the design point vecx^*.","category":"page"},{"location":"ReliabilityProblems/SORM/#Point-Fitting-Method","page":"Second-Order Reliability Methods","title":"Point-Fitting Method","text":"","category":"section"},{"location":"ReliabilityProblems/SORM/","page":"Second-Order Reliability Methods","title":"Second-Order Reliability Methods","text":"warning: Warning\nThis feature is currently under development.","category":"page"},{"location":"ReliabilityProblems/SORM/#API","page":"Second-Order Reliability Methods","title":"API","text":"","category":"section"},{"location":"ReliabilityProblems/SORM/","page":"Second-Order Reliability Methods","title":"Second-Order Reliability Methods","text":"SORM\nSORMSubmethod\nanalyze(Problem::ReliabilityProblem, AnalysisMethod::SORM)","category":"page"},{"location":"ReliabilityProblems/SORM/#Fortuna.SORM","page":"Second-Order Reliability Methods","title":"Fortuna.SORM","text":"struct SORM <: AbstractReliabililyAnalysisMethod\n\nA custom type used by Fortuna.jl to perform reliability analysis using Second-Order Reliability Methods.\n\nSubmethod: Analysis method that falls under the category of Second-Order Reliability Methods.\n\n\n\n\n\n","category":"type"},{"location":"ReliabilityProblems/SORM/#Fortuna.SORMSubmethod","page":"Second-Order Reliability Methods","title":"Fortuna.SORMSubmethod","text":"abstract type SORMSubmethod end\n\nA custom abstract supertype used by Fortuna.jl to define various types of Second-Order Reliability Methods.\n\n\n\n\n\n","category":"type"},{"location":"ReliabilityProblems/SORM/#Fortuna.analyze-Tuple{ReliabilityProblem, SORM}","page":"Second-Order Reliability Methods","title":"Fortuna.analyze","text":"analyze(Problem::ReliabilityProblem, AnalysisMethod::SORM)\n\nThe function solves the provided reliability problem using any submethod that falls under a broader category of Second-Order Reliability Methods (SORM).\n\n\n\n\n\n","category":"method"},{"location":"#Fortuna","page":"Home","title":"Fortuna","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Audentes Fortuna Iuvat","category":"page"},{"location":"#Description","page":"Home","title":"Description","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Fortuna.jl is a general-purpose Julia package for structural and system reliability analysis.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install Fortuna.jl package, type ] in Julia REPL to enter the built-in Julia package manager and execute the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add Fortuna","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Fortuna.jl package is distributed under the MIT license. More information can be found in the LICENSE.md file.","category":"page"},{"location":"#Help-and-Support","page":"Home","title":"Help and Support","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For assistance with the package, please raise an issue on the Github Issues page. Please use the appropriate labels to indicate the specific functionality you are inquiring about. Alternatively, contact the author directly at AkchurinDA@gmail.com.","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The author thanks the academic and industrial partners of the Cold-Formed Steel Research Consortium’s “Reliability 2030” initiative for their financial support.","category":"page"}]
}
