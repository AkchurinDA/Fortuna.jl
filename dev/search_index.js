var documenterSearchIndex = {"docs":
[{"location":"Reliability Problems/MC/#Monte-Carlo-Simulations","page":"Direct Monte Carlo Simulations","title":"Monte Carlo Simulations","text":"","category":"section"},{"location":"Reliability Problems/MC/#Overview","page":"Direct Monte Carlo Simulations","title":"Overview","text":"","category":"section"},{"location":"Reliability Problems/MC/","page":"Direct Monte Carlo Simulations","title":"Direct Monte Carlo Simulations","text":"Using direct Monte Carlo simulations (MCS) is the simplest way to estimate the probability of failure P_f for reliability problems with both simple and complex limit state functions g(vecX). The brute force MCS relies on the following reformulation of the general analytical expression for the probability of failure P_f:","category":"page"},{"location":"Reliability Problems/MC/","page":"Direct Monte Carlo Simulations","title":"Direct Monte Carlo Simulations","text":"P_f = P(Omega_f) = int_Omega_f f_vecX(vecx) dvecx = int_mathbbR^n mathbbI(vecx) f_vecX(vecx) dvecx = mathbbE_fmathbbI(vecx)","category":"page"},{"location":"Reliability Problems/MC/","page":"Direct Monte Carlo Simulations","title":"Direct Monte Carlo Simulations","text":"where f_vecX(vecx) is the joint probability function of the input random vector vecX, Omega_f = vecX g(vecX) leq 0 is the failure domain defined by the limit state function g(vecX), and mathbbI(vecx) is the indicator function given by:","category":"page"},{"location":"Reliability Problems/MC/","page":"Direct Monte Carlo Simulations","title":"Direct Monte Carlo Simulations","text":"mathbbI(vecx) = \nbegincases\n    1  textif  vecx in Omega_f \n    0  textotherwise\nendcases","category":"page"},{"location":"Reliability Problems/MC/","page":"Direct Monte Carlo Simulations","title":"Direct Monte Carlo Simulations","text":"Therefore, the probability of failure P_f is defined as the expectation of the indicator function mathbbI(vecx). If samples of the input random vector vecx are generated numerically, then the estimator of the probability of failure hatP_f is","category":"page"},{"location":"Reliability Problems/MC/","page":"Direct Monte Carlo Simulations","title":"Direct Monte Carlo Simulations","text":"hatP_f = dfrac1N sum_i = 1^N mathbbI(vecx_i)","category":"page"},{"location":"Reliability Problems/MC/","page":"Direct Monte Carlo Simulations","title":"Direct Monte Carlo Simulations","text":"where N is the number of generated sampled. The estimator hatP_f is unbiased, i.e., it correctly predicts the true probability of failure, such that  mathbbE(hatP_f) = P_f. The main drawback of using the MCS is that is becomes prohibitively expensive to use if the true probability is too small, e.g., P_f leq 10^-6, given that the variance of the estimator is inversely proportional to the number of generated samples, such that,","category":"page"},{"location":"Reliability Problems/MC/","page":"Direct Monte Carlo Simulations","title":"Direct Monte Carlo Simulations","text":"textVar(hatP_f) = frac1N P_f (1 - P_f)","category":"page"},{"location":"Reliability Problems/MC/","page":"Direct Monte Carlo Simulations","title":"Direct Monte Carlo Simulations","text":"tip: Tip\nFor typical structural reliability problems with true probabilities of failure P_f of approx 10^-3, it is recommended to use N = 10^6 samples to get the coefficient of variation of the estimator V_P_f of approx 010.<img src=\"../../assets/Theory-MonteCarlo-1.png\" class=\"center\" style=\"max-height:350px; border-radius:2.5px;\"/>","category":"page"},{"location":"Reliability Problems/MC/#API","page":"Direct Monte Carlo Simulations","title":"API","text":"","category":"section"},{"location":"Reliability Problems/MC/#Fortuna.solve-Tuple{ReliabilityProblem, MC}","page":"Direct Monte Carlo Simulations","title":"Fortuna.solve","text":"solve(Problem::ReliabilityProblem, AnalysisMethod::MC; showprogressbar = false)\n\nFunction used to solve reliability problems using Monte Carlo (MC) simulations.\n\n\n\n\n\n","category":"method"},{"location":"Reliability Problems/MC/#Fortuna.MC","page":"Direct Monte Carlo Simulations","title":"Fortuna.MC","text":"MC <: AbstractReliabililyAnalysisMethod\n\nType used to perform reliability analysis using Monte Carlo (MC) simulations.\n\nNumSimulations::Integer: Number of simulations N\nSamplingTechnique::Symbol: Sampling technique\n\n\n\n\n\n","category":"type"},{"location":"Reliability Problems/MC/#Fortuna.MCCache","page":"Direct Monte Carlo Simulations","title":"Fortuna.MCCache","text":"MCCache\n\nType used to store results of reliability analysis performed using Monte Carlo (MC) simulations.\n\nSamples::Matrix{Float64}: Generated samples vecx_i\ngValues::Vector{Float64}: Limit state function evalued at each sample g(vecx_i)\nPoF::Float64: Probability of failure P_f\n\n\n\n\n\n","category":"type"},{"location":"BasicExamples/#Examples","page":"Basic Examples","title":"Examples","text":"","category":"section"},{"location":"BasicExamples/#Isoprobabilistic-Transformations","page":"Basic Examples","title":"Isoprobabilistic Transformations","text":"","category":"section"},{"location":"BasicExamples/#Nataf-Transformation","page":"Basic Examples","title":"Nataf Transformation","text":"","category":"section"},{"location":"BasicExamples/","page":"Basic Examples","title":"Basic Examples","text":"# Define random vector:\nX_1 = randomvariable(\"Gamma\", \"M\", [10, 1.5])\nX_2 = randomvariable(\"Gamma\", \"M\", [15, 2.5])\nX   = [X_1, X_2]\n\n# Define correlation matrix:\nρ_X = [1 -0.75; -0.75 1]\n\n# Perform Nataf Transformation:\nnataf_object = NatafTransformation(X, ρ_X)\n\n# Generate 10000 samples of random vector in X-, Z-, and U-spaces using Latin Hypercube Sampling technique:\nX_samples, U_samples, Z_samples = rand(nataf_object, 10000, :LHS)\n\nnothing # hide","category":"page"},{"location":"BasicExamples/","page":"Basic Examples","title":"Basic Examples","text":"<img src=\"../assets/Examples-NatafTransformation-1.png\" class=\"center\" style=\"max-height:350px; border-radius:2.5px;\"/>","category":"page"},{"location":"BasicExamples/","page":"Basic Examples","title":"Basic Examples","text":"# Compute joint PDF of random vector:\nx_range_1  = range(0, 20, 500)\nx_range_2  = range(5, 25, 500)\nf_samples  = [pdf(nataf_object, [x_1, x_2]) for x_1 in x_range_1, x_2 in x_range_2]\n\nnothing # hide","category":"page"},{"location":"BasicExamples/","page":"Basic Examples","title":"Basic Examples","text":"<img src=\"../assets/Examples-NatafTransformation-2.png\" class=\"center\" style=\"max-height:350px; border-radius:2.5px;\"/>","category":"page"},{"location":"BasicExamples/#Monte-Carlo-Methods","page":"Basic Examples","title":"Monte Carlo Methods","text":"","category":"section"},{"location":"BasicExamples/#Direct-Monte-Carlo-Simulations","page":"Basic Examples","title":"Direct Monte Carlo Simulations","text":"","category":"section"},{"location":"BasicExamples/","page":"Basic Examples","title":"Basic Examples","text":"# Define random vector:\nX_1 = randomvariable(\"Normal\", \"M\", [0, 1])\nX_2 = randomvariable(\"Normal\", \"M\", [0, 1])\nX   = [X_1, X_2]\n\n# Define correlation matrix:\nρ_X = [1 0; 0 1]\n\n# Define limit state function:\nβ            = 3\ng(x::Vector) = β * sqrt(2) - x[1] - x[2]\n\n# Define reliability problem:\nproblem = ReliabilityProblem(X, ρ_X, g)\n\n# Perform reliability analysis using Monte Carlo simulations:\nsolution = solve(problem, MC())\nprintln(\"MC:\")\nprintln(\"PoF: $(solution.PoF)\")","category":"page"},{"location":"BasicExamples/","page":"Basic Examples","title":"Basic Examples","text":"<img src=\"../assets/Examples-MonteCarlo-1.png\" class=\"center\" style=\"max-height:350px; border-radius:2.5px;\"/>","category":"page"},{"location":"BasicExamples/#Importance-Sampling-Method","page":"Basic Examples","title":"Importance Sampling Method","text":"","category":"section"},{"location":"BasicExamples/","page":"Basic Examples","title":"Basic Examples","text":"# Define proposal probability density function:\nq = MvNormal([β / sqrt(2), β / sqrt(2)], [1 0; 0 1])\n\n# Perform reliability analysis using Monte Carlo simulations:\nsolution = solve(problem, IS(q = q))\nprintln(\"IS:\")\nprintln(\"PoF: $(solution.PoF)\")","category":"page"},{"location":"BasicExamples/","page":"Basic Examples","title":"Basic Examples","text":"<img src=\"../assets/Examples-ImportanceSampling-1.png\" class=\"center\" style=\"max-height:350px; border-radius:2.5px;\"/>","category":"page"},{"location":"BasicExamples/","page":"Basic Examples","title":"Basic Examples","text":"<img src=\"../assets/Examples-ImportanceSampling-2.png\" class=\"center\" style=\"max-height:350px; border-radius:2.5px;\"/>","category":"page"},{"location":"BasicExamples/#First-Order-Reliability-Methods","page":"Basic Examples","title":"First-Order Reliability Methods","text":"","category":"section"},{"location":"BasicExamples/#Mean-Centered-First-Order-Second-Moment-Method","page":"Basic Examples","title":"Mean-Centered First-Order Second-Moment Method","text":"","category":"section"},{"location":"BasicExamples/","page":"Basic Examples","title":"Basic Examples","text":"# Define random vector:\nX_1 = randomvariable(\"Normal\", \"M\", [10, 2])\nX_2 = randomvariable(\"Normal\", \"M\", [20, 5])\nX   = [X_1, X_2]\n\n# Define correlation matrix:\nρ_X = [1 0.5; 0.5 1]\n\n# Define two equivalent limit state functions:\ng_1(x::Vector) = x[1] ^ 2 - 2 * x[2]\ng_2(x::Vector) = 1 - 2 * x[2] / x[1] ^ 2\n\n# Define reliability problems:\nproblem_1 = ReliabilityProblem(X, ρ_X, g_1)\nproblem_2 = ReliabilityProblem(X, ρ_X, g_2)\n\n# Perform reliability analysis using Mean-Centered First-Order Second-Moment (MCFOSM) method:\nsolution_1 = solve(problem_1, FORM(MCFOSM()))\nsolution_2 = solve(problem_2, FORM(MCFOSM()))\nprintln(\"MCFOSM:\")\nprintln(\"β from g₁: $(solution_1.β)\")\nprintln(\"β from g₂: $(solution_2.β)\")","category":"page"},{"location":"BasicExamples/#Hasofer-Lind-Rackwitz-Fiessler-Method","page":"Basic Examples","title":"Hasofer-Lind-Rackwitz-Fiessler Method","text":"","category":"section"},{"location":"BasicExamples/","page":"Basic Examples","title":"Basic Examples","text":"# Perform reliability analysis using Hasofer-Lind-Rackwitz-Fiessler (HLRF) method:\nsolution_1 = solve(problem_1, FORM(HLRF()))\nsolution_2 = solve(problem_2, FORM(HLRF()))\nprintln(\"FORM:\")\nprintln(\"β from g₁: $(solution_1.β)\")\nprintln(\"β from g₂: $(solution_2.β)\")","category":"page"},{"location":"BasicExamples/#Improved-Hasofer-Lind-Rackwitz-Fiessler-Method","page":"Basic Examples","title":"Improved Hasofer-Lind-Rackwitz-Fiessler Method","text":"","category":"section"},{"location":"BasicExamples/","page":"Basic Examples","title":"Basic Examples","text":"# Perform reliability analysis using improved Hasofer-Lind-Rackwitz-Fiessler (iHLRF) method:\nsolution_1 = solve(problem_1, FORM(iHLRF()))\nsolution_2 = solve(problem_2, FORM(iHLRF()))\nprintln(\"FORM:\")\nprintln(\"β from g₁: $(solution_1.β)\")\nprintln(\"β from g₂: $(solution_2.β)\")","category":"page"},{"location":"BasicExamples/#Second-Order-Reliability-Methods","page":"Basic Examples","title":"Second-Order Reliability Methods","text":"","category":"section"},{"location":"BasicExamples/#Curve-Fitting-Method","page":"Basic Examples","title":"Curve-Fitting Method","text":"","category":"section"},{"location":"BasicExamples/","page":"Basic Examples","title":"Basic Examples","text":"# Define random vector:\nM_1 = randomvariable(\"Normal\", \"M\", [250, 250 * 0.3])\nM_2 = randomvariable(\"Normal\", \"M\", [125, 125 * 0.3])\nP   = randomvariable(\"Gumbel\", \"M\", [2500, 2500 * 0.2])\nY   = randomvariable(\"Weibull\", \"M\", [40000, 40000 * 0.1])\nX   = [M_1, M_2, P, Y]\n\n# Define correlation matrix:\nρ_X = [1 0.5 0.3 0; 0.5 1 0.3 0; 0.3 0.3 1 0; 0 0 0 1]\n\n# Define limit state function:\na   = 0.190\ns_1 = 0.030\ns_2 = 0.015\ng(x::Vector) = 1 - x[1] / (s_1 * x[4]) - x[2] / (s_2 * x[4]) - (x[3] / (a * x[4])) ^ 2\n\n# Define reliability problem:\nproblem = ReliabilityProblem(X, ρ_X, g)\n\n# Perform reliability analysis using Curve-Fitting (CF) method:\nsolution = solve(problem, SORM(CF()))\nprintln(\"SORM:\")\nprintln(\"β from FORM: $(solution.FORMSolution.β)\")\nprintln(\"β from SORM: $(solution.β₂[1]) (Hohenbichler and Rackwitz)\")\nprintln(\"β from SORM: $(solution.β₂[2]) (Breitung)\")\nprintln(\"PoF from FORM: $(solution.FORMSolution.PoF)\")\nprintln(\"PoF from SORM: $(solution.PoF₂[1]) (Hohenbichler and Rackwitz)\")\nprintln(\"PoF from SORM: $(solution.PoF₂[2]) (Breitung)\")","category":"page"},{"location":"BasicExamples/#Point-Fitting-Method","page":"Basic Examples","title":"Point-Fitting Method","text":"","category":"section"},{"location":"BasicExamples/","page":"Basic Examples","title":"Basic Examples","text":"# Perform reliability analysis using point-fitting SORM:\nsolution = solve(problem, SORM(PF()))\nprintln(\"SORM:\")\nprintln(\"β from FORM: $(solution.FORMSolution.β)\")\nprintln(\"β from SORM: $(solution.β₂[1]) (Hohenbichler and Rackwitz)\")\nprintln(\"β from SORM: $(solution.β₂[2]) (Breitung)\")\nprintln(\"PoF from FORM: $(solution.FORMSolution.PoF)\")\nprintln(\"PoF from SORM: $(solution.PoF₂[1]) (Hohenbichler and Rackwitz)\")\nprintln(\"PoF from SORM: $(solution.PoF₂[2]) (Breitung)\")","category":"page"},{"location":"BasicExamples/#Subset-Simulation-Method","page":"Basic Examples","title":"Subset Simulation Method","text":"","category":"section"},{"location":"BasicExamples/","page":"Basic Examples","title":"Basic Examples","text":"# Define random vector:\nX_1 = randomvariable(\"Normal\", \"M\", [0, 1])\nX_2 = randomvariable(\"Normal\", \"M\", [0, 1])\nX  = [X_1, X_2]\n\n# Define correlation matrix:\nρ_X  = [1 0; 0 1]\n\n# Define limit state function:\nβ = 3\ng(x::Vector) = β * sqrt(2) - x[1] - x[2]\n\n# Define reliability problem:\nproblem = ReliabilityProblem(X, ρ_X, g)\n\n# Perform reliability analysis using Monte Carlo simulations:\nsolution = solve(problem, SSM())\nprintln(\"SSM:\")\nprintln(\"PoF: $(solution.PoF)\")","category":"page"},{"location":"BasicExamples/","page":"Basic Examples","title":"Basic Examples","text":"<img src=\"../assets/Examples-SubsetSimulationMethod-1.png\" class=\"center\" style=\"max-height:350px; border-radius:2.5px;\"/>","category":"page"},{"location":"InverseReliabilityProblems/#Inverse-Reliability-Problems","page":"Inverse Reliability Problems","title":"Inverse Reliability Problems","text":"","category":"section"},{"location":"InverseReliabilityProblems/#Defining-Inverse-Reliability-Problems","page":"Inverse Reliability Problems","title":"Defining Inverse Reliability Problems","text":"","category":"section"},{"location":"InverseReliabilityProblems/","page":"Inverse Reliability Problems","title":"Inverse Reliability Problems","text":"In general, 4 main \"items\" are always need to fully define an inverse reliability problem and successfully solve it to find the parameter of interest theta:","category":"page"},{"location":"InverseReliabilityProblems/","page":"Inverse Reliability Problems","title":"Inverse Reliability Problems","text":"Item Description\nvecX Random vector with correlated non-normal marginals\nrho^X Correlation matrix\ng(vecX theta) Limit state function\nbeta Target reliability index","category":"page"},{"location":"InverseReliabilityProblems/","page":"Inverse Reliability Problems","title":"Inverse Reliability Problems","text":"Fortuna.jl package uses these 4 \"items\" to fully define inverse reliability problems of type I using SensitivityProblem() type as shown in the example below.","category":"page"},{"location":"InverseReliabilityProblems/#Solving-Inverse-Reliability-Problems","page":"Inverse Reliability Problems","title":"Solving Inverse Reliability Problems","text":"","category":"section"},{"location":"InverseReliabilityProblems/","page":"Inverse Reliability Problems","title":"Inverse Reliability Problems","text":"# Define the random vector:\nX_1 = randomvariable(\"Normal\", \"M\", [0, 1])\nX_2 = randomvariable(\"Normal\", \"M\", [0, 1])\nX_3 = randomvariable(\"Normal\", \"M\", [0, 1])\nX_4 = randomvariable(\"Normal\", \"M\", [0, 1])\nX   = [X_1, X_2, X_3, X_4]\n\n# Define the correlation matrix:\nρ_X = Matrix{Float64}(1.0 * I, 4, 4)\n\n# Define the limit state function:\ng(x::Vector, θ::Real) = exp(-θ * (x[1] + 2 * x[2] + 3 * x[3])) - x[4] + 1.5\n\n# Define the target reliability index:\nβ = 2\n\n# Define an inverse reliability problem:\nproblem = InverseReliabilityProblem(X, ρ_X, g, β)\n\nnothing # hide","category":"page"},{"location":"InverseReliabilityProblems/#Solving-Inverse-Reliability-Problems-2","page":"Inverse Reliability Problems","title":"Solving Inverse Reliability Problems","text":"","category":"section"},{"location":"InverseReliabilityProblems/","page":"Inverse Reliability Problems","title":"Inverse Reliability Problems","text":"After defining an inverse reliability problem, Fortuna.jl allows to easily solve it using a single solve() function as shown in the example below.","category":"page"},{"location":"InverseReliabilityProblems/","page":"Inverse Reliability Problems","title":"Inverse Reliability Problems","text":"# Perform the inverse reliability analysis:\nsolution = solve(problem, 0.1, x₀ = [0.2, 0.2, 0.2, 0.2])\nprintln(\"x = $(solution.x[:, end])\")\nprintln(\"θ = $(solution.θ[end])\")","category":"page"},{"location":"InverseReliabilityProblems/#API","page":"Inverse Reliability Problems","title":"API","text":"","category":"section"},{"location":"InverseReliabilityProblems/#Fortuna.solve-Tuple{InverseReliabilityProblem, Real}","page":"Inverse Reliability Problems","title":"Fortuna.solve","text":"solve(Problem::InverseReliabilityProblem, θ₀::Real; \n    x₀::Union{Nothing, Vector{<:Real}} = nothing, \n    MaxNumIterations = 250, ϵ₁ = 10E-6, ϵ₂ = 10E-6, ϵ₃ = 10E-3,\n    backend = AutoForwardDiff())\n\nFunction used to solve inverse reliability problems.\n\n\n\n\n\n","category":"method"},{"location":"InverseReliabilityProblems/#Fortuna.InverseReliabilityProblem","page":"Inverse Reliability Problems","title":"Fortuna.InverseReliabilityProblem","text":"InverseReliabilityProblem <: AbstractReliabilityProblem\n\nType used to define inverse reliability problems.\n\nX::AbstractVector{<:UnivariateDistribution}: Random vector vecX\nρˣ::AbstractMatrix{<:Real}: Correlation matrix rho^X\ng::Function: Limit state function g(vecX theta)\nβ::Real: Target reliability index beta_t\n\n\n\n\n\n","category":"type"},{"location":"InverseReliabilityProblems/#Fortuna.InverseReliabilityProblemCache","page":"Inverse Reliability Problems","title":"Fortuna.InverseReliabilityProblemCache","text":"InverseReliabilityProblemCache\n\nType used to store results of inverse reliability analysis.\n\nx::Matrix{Float64}: Design points in X-space at each iteration vecx_i^*\nu::Matrix{Float64}: Design points in U-space at each iteration vecu_i^*\nθ::Vector{Float64}: Parameter of interest at each iteration theta_i\nG::Vector{Float64}: Limit state function at each iteration G(vecu_i^* theta_i)\n∇Gu::Matrix{Float64}: Gradient of the limit state function at each iteration nabla_vecu G(vecu_i^* theta_i)\n∇Gθ::Vector{Float64}: Gradient of the limit state function at each iteration nabla_theta G(vecu_i^* theta_i)\nα::Matrix{Float64}: Normalized negative gradient of the limit state function at each iteration vecalpha_i\ndu::Matrix{Float64}: Search direction for the design point in U-space at each iteration vecd_u_i\ndθ::Vector{Float64}: Search direction for the parameter of interest at each iteration vecd_u_i\nc₁::Vector{Float64}: c_1-coefficients at each iteration c_1_i\nc₂::Vector{Float64}: c_2-coefficients at each iteration c_2_i\nm₁::Vector{Float64}: First merit function at each iteration m_1_i\nm₂::Vector{Float64}: Second merit function at each iteration m_2_i\nm::Vector{Float64}: Merit function at each iteration m_i\nλ::Vector{Float64}: Step size at each iteration lambda_i\n\n\n\n\n\n","category":"type"},{"location":"References/#References","page":"References","title":"References","text":"","category":"section"},{"location":"References/","page":"References","title":"References","text":"Au, S.-K. and Beck, J. L. (2001). Estimation of Small Failure Probabilities in High Dimensions by Subset Simulation. Probabilistic Engineering Mechanics 16, 263–277. Accessed on Mar 10, 2024.\n\n\n\nBreitung, K. (1984). Asymptotic Approximations for Multinormal Integrals. Journal of Engineering Mechanics 110, 357–366.\n\n\n\nDer Kiureghian, A. (2022). Structural and System Reliability (Cambridge University Press).\n\n\n\nHohenbichler, M. and Rackwitz, R. (1988). Improvement Of Second‐Order Reliability Estimates by Importance Sampling. Journal of Engineering Mechanics 114, 2195–2199.\n\n\n\nNataf, A. (1962). Détermination des Distribution dont les Marges sont Données. Comptes Rendus de l'Académie des Sciences 225, 42–43.\n\n\n\nRosenblatt, M. (1952). Remarks on a Multivariate Transformation. The Annals of Mathematical Statistics 23, 470–472.\n\n\n\nTvedt, L. (1990). Distribution of Quadratic Forms in Normal Space—Application to Structural Reliability. Journal of Engineering Mechanics 116, 1183–1197.\n\n\n\n","category":"page"},{"location":"Reliability Problems/FORM/#FORMPage","page":"First-Order Reliability Methods","title":"First-Order Reliability Methods","text":"","category":"section"},{"location":"Reliability Problems/FORM/#Mean-Centered-First-Order-Second-Moment-Method","page":"First-Order Reliability Methods","title":"Mean-Centered First-Order Second-Moment Method","text":"","category":"section"},{"location":"Reliability Problems/FORM/","page":"First-Order Reliability Methods","title":"First-Order Reliability Methods","text":"The MCFOSM method is the simplest and least computationally expensive type of reliability method. It utilizes the first-order Taylor expansion of the limit state function g(vecX) at the mean values and the first two moments of the marginal random variables involved in the reliability problem to evaluate the reliability index. However, despite the fact that it is simple and does not require the complete knowledge of the random variables involved in the reliability problem, the MCFOSM method faces an issue known as the invariance problem. This problem arises because the resulting reliability index beta is dependent on the formulation of the limit state function g(vecX). In other words, two equivalent limit state functions with the same failure boundaries produce two different reliability indices; thus, the use of MCFOSM method is not recommended.","category":"page"},{"location":"Reliability Problems/FORM/#Rackwitz-Fiessler-Method","page":"First-Order Reliability Methods","title":"Rackwitz-Fiessler Method","text":"","category":"section"},{"location":"Reliability Problems/FORM/","page":"First-Order Reliability Methods","title":"First-Order Reliability Methods","text":"The RF method, also known as the Equivalent Normal method, is an efficient way to solve reliability problems involving strictly uncorrelated random variables. The RF method overcomes the invariance problem faced by the MCFOSM method by using the first-order Taylor expansion of the limit state function at a point known as the design point vecx^* that lies on the failure boundary given by g(vecX) = 0. Since the design point vecx^* is not known a priori, the RF method is inherently an iterative method. At each iteration, the RF method replaces the original random variables with equivalent normal random variables, which allows for a direct transformation from the original non-normal space into the standard normal space in which the reliability index beta is calculated.","category":"page"},{"location":"Reliability Problems/FORM/#Plain-and-Improved-Hasofer-Lind-Rackwitz-Fiessler-Method","page":"First-Order Reliability Methods","title":"Plain and Improved Hasofer-Lind-Rackwitz-Fiessler Method","text":"","category":"section"},{"location":"Reliability Problems/FORM/","page":"First-Order Reliability Methods","title":"First-Order Reliability Methods","text":"The HLRF method is the most accepted and efficient way to solve reliability problems involving both uncorrelated and correlated random variables. The HLRF method also overcomes the invariance problem faced by the MCFOSM method by using the first-order Taylor expansion of the limit state function at the design point vecx^*. Again, since the design point vecx^* is not known a priori, the HLRF method is inherently an iterative method. At each iteration, the HLRF method performs Nataf Transformation to transformation from the original non-normal space into the standard normal space in which the reliability index beta is calculated. Fortuna.jl package implements two versions of HLRF method: plain HLRF method where the step size lamba in the negative gradient descent is always set to unity and improved HLRF (iHLRF) method where the step size lamba is determined using a line search algorithm.","category":"page"},{"location":"Reliability Problems/FORM/#API","page":"First-Order Reliability Methods","title":"API","text":"","category":"section"},{"location":"Reliability Problems/FORM/#Fortuna.solve-Tuple{ReliabilityProblem, FORM}","page":"First-Order Reliability Methods","title":"Fortuna.solve","text":"solve(Problem::ReliabilityProblem, AnalysisMethod::FORM; backend = AutoForwardDiff())\n\nFunction used to solve reliability problems using First-Order Reliability Method (FORM).\n\n\n\n\n\n","category":"method"},{"location":"Reliability Problems/FORM/#Fortuna.FORM","page":"First-Order Reliability Methods","title":"Fortuna.FORM","text":"FORM <: AbstractReliabililyAnalysisMethod\n\nType used to perform reliability analysis using First-Order Reliability Method (FORM).\n\nSubmethod::Fortuna.FORMSubmethod\n\n\n\n\n\n","category":"type"},{"location":"Reliability Problems/FORM/#Fortuna.MCFOSM","page":"First-Order Reliability Methods","title":"Fortuna.MCFOSM","text":"MCFOSM <: FORMSubmethod\n\nType used to perform reliability analysis using Mean-Centered First-Order Second-Moment (MCFOSM) method.\n\n\n\n\n\n","category":"type"},{"location":"Reliability Problems/FORM/#Fortuna.MCFOSMCache","page":"First-Order Reliability Methods","title":"Fortuna.MCFOSMCache","text":"MCFOSMCache\n\nType used to store results of reliability analysis performed using Mean-Centered First-Order Second-Moment (MCFOSM) method.\n\nβ::Float64: Reliability index beta\n\n\n\n\n\n","category":"type"},{"location":"Reliability Problems/FORM/#Fortuna.HLRF","page":"First-Order Reliability Methods","title":"Fortuna.HLRF","text":"HLRF <: FORMSubmethod\n\nType used to perform reliability analysis using Hasofer-Lind Rackwitz-Fiessler (HLRF) method.\n\nMaxNumIterations::Integer: Maximum number of iterations\nϵ₁::Real: Convergance criterion #1 epsilon_1\nϵ₂::Real: Convergance criterion #1 epsilon_2\nx₀::Union{Nothing, Vector{<:Real}}: Starting point x_0\n\n\n\n\n\n","category":"type"},{"location":"Reliability Problems/FORM/#Fortuna.HLRFCache","page":"First-Order Reliability Methods","title":"Fortuna.HLRFCache","text":"HLRFCache\n\nType used to store results of reliability analysis performed using Hasofer-Lind Rackwitz-Fiessler (HLRF) method.\n\nβ::Float64: Reliability index beta\nPoF::Float64: Probability of failure P_f\nx::Matrix{Float64}: Design points in X-space at each iteration vecx_i^*\nu::Matrix{Float64}: Design points in U-space at each iteration vecu_i^*\nG::Vector{Float64}: Limit state function at each iteration G(vecu_i^*)\n∇G::Matrix{Float64}: Gradient of the limit state function at each iteration nabla G(vecu_i^*)\nα::Matrix{Float64}: Normalized negative gradient of the limit state function at each iteration vecalpha_i\nd::Matrix{Float64}: Search direction at each iteration vecd_i\nγ::Vector{Float64}: Importance vector vecgamma\nConvergance::Bool: Convergance status\n\n\n\n\n\n","category":"type"},{"location":"Reliability Problems/FORM/#Fortuna.iHLRF","page":"First-Order Reliability Methods","title":"Fortuna.iHLRF","text":"iHLRF <: FORMSubmethod\n\nType used to perform reliability analysis using improved Hasofer-Lind Rackwitz-Fiessler (iHLRF) method.\n\nMaxNumIterations::Integer: Maximum number of iterations\nϵ₁::Real: Convergance criterion #1 epsilon_1\nϵ₂::Real: Convergance criterion #1 epsilon_2\nx₀::Union{Nothing, Vector{<:Real}}: Starting point x_0\nc₀::Union{Nothing, Real}: c-coefficient applied at each iteration c_0\n\n\n\n\n\n","category":"type"},{"location":"Reliability Problems/FORM/#Fortuna.iHLRFCache","page":"First-Order Reliability Methods","title":"Fortuna.iHLRFCache","text":"iHLRFCache\n\nType used to store results of reliability analysis performed using improved Hasofer-Lind Rackwitz-Fiessler (iHLRF) method.\n\nβ::Float64: Reliability index beta\nPoF::Float64: Probability of failure P_f\nx::Matrix{Float64}: Design points in X-space at each iteration vecx_i^*\nu::Matrix{Float64}: Design points in U-space at each iteration vecu_i^*\nG::Vector{Float64}: Limit state function at each iteration G(vecu_i^*)\n∇G::Matrix{Float64}: Gradient of the limit state function at each iteration nabla G(vecu_i^*)\nα::Matrix{Float64}: Normalized negative gradient of the limit state function at each iteration vecalpha_i\nd::Matrix{Float64}: Search direction at each iteration vecd_i\nc::Vector{Float64}: c-coefficient at each iteration c_i\nm::Vector{Float64}: Merit function at each iteration m_i\nλ::Vector{Float64}: Step size at each iteration lambda_i\nγ::Vector{Float64}: Importance vector vecgamma\nConvergance::Bool: Convergance status\n\n\n\n\n\n","category":"type"},{"location":"Isoprobabilistic Transformations/NatafTransformation/#NatafTransformationPage","page":"Nataf Transformation","title":"Nataf Transformation","text":"","category":"section"},{"location":"Isoprobabilistic Transformations/NatafTransformation/#Overview","page":"Nataf Transformation","title":"Overview","text":"","category":"section"},{"location":"Isoprobabilistic Transformations/NatafTransformation/","page":"Nataf Transformation","title":"Nataf Transformation","text":"The Nataf Transformation is a widely utilized isoprobabilistic transformation in structural reliability analysis. Its purpose is to transform random vectors with correlated non-normal marginals vecX into random vectors with uncorrelated standard normal marginals vecU. This transformation was first introduced by André Nataf in 1962 Nataf (1962).","category":"page"},{"location":"Isoprobabilistic Transformations/NatafTransformation/","page":"Nataf Transformation","title":"Nataf Transformation","text":"The Nataf Transformation vecU = T^N(vecX) is composed of two transformations: ","category":"page"},{"location":"Isoprobabilistic Transformations/NatafTransformation/","page":"Nataf Transformation","title":"Nataf Transformation","text":"vecU = T^N(vecX) = (T_2^N circ T_1^N)(vecX)","category":"page"},{"location":"Isoprobabilistic Transformations/NatafTransformation/","page":"Nataf Transformation","title":"Nataf Transformation","text":"The first transformation vecZ = T_1^N(vecX) transforms random vector with correlated non-normal marginals vecX (with correlation matrix rho^X) into random vector with correlated standard normal marginals vecZ (with correlation matrix rho^Z). Here, Phi^-1(cdot) is the inverse of the cumulative density function of a standard normal random variable and F_X_i(cdot) is the cumulative density function of a marginalX_i.","category":"page"},{"location":"Isoprobabilistic Transformations/NatafTransformation/","page":"Nataf Transformation","title":"Nataf Transformation","text":"vecZ = T_1^N(vecX) = \nbeginbmatrix \n    Phi^-1(F_X_1(X_1))  \n    Phi^-1(F_X_2(X_2)) \n    vdots  \n    Phi^-1(F_X_n(X_n)) \nendbmatrix ","category":"page"},{"location":"Isoprobabilistic Transformations/NatafTransformation/","page":"Nataf Transformation","title":"Nataf Transformation","text":"The second transformation vecU = T_2^N(vecZ) transforms random vector with correlated standard normal marginals vecZ into random vector with uncorrelated standard normal marginals vecU. Here, the matrix Gamma is used to decorrelate the standard normal marginals of random vector vecZ and can be chosen as any square-root matrix of the correlation matrix rho^Z. Fortuna.jl uses the Cholesky factor of the inverse of the correlation matrix (rho^Z)^-1 as the matrix Gamma.","category":"page"},{"location":"Isoprobabilistic Transformations/NatafTransformation/","page":"Nataf Transformation","title":"Nataf Transformation","text":"vecU = T_2^N(vecZ) = Gamma vecZ","category":"page"},{"location":"Isoprobabilistic Transformations/NatafTransformation/","page":"Nataf Transformation","title":"Nataf Transformation","text":"The first transformation vecZ = T_1^N(vecX) causes so-called correlation distortion. The correlation distortion causes the correlation coefficient between two standard normal marginals Z_i and Z_j, denoted by rho_ij^Z, to distort and differ from the original correlation coefficient between the corresponding non-normal marginals X_i and X_j, denoted by rho_ij^X, such that rho_ij^Z neq rho_ij^X. The relationship between the components of the correlation matrices rho_ij^Z and rho_ij^X is given by","category":"page"},{"location":"Isoprobabilistic Transformations/NatafTransformation/","page":"Nataf Transformation","title":"Nataf Transformation","text":"rho_ij^X = dfrac1sigma_X_i sigma_X_j int_-infty^infty int_-infty^infty (F_X_i^-1(Phi(z_i)) - mu_X_i) (F_X_j^-1(Phi(z_j)) - mu_X_j) phi_2(z_i z_j rho_ij^Z) dz_i dz_j","category":"page"},{"location":"Isoprobabilistic Transformations/NatafTransformation/","page":"Nataf Transformation","title":"Nataf Transformation","text":"where phi_2(cdot) is the bivariate standard normal probability density function. Generally, this integral cannot be inverted analytically to solve for the coefficients of the distorted correlation matrix rho_ij^Z. In order to compute these coefficients, Fortuna.jl package (1) employs a two-dimensions Gauss-Legendre quadrature implemented in FastGaussQuadrature.jl package to expand the integral into a finite summation using Gauss–Legendre quadrature and (2) utilizes NonlinearSolve.jl package to find values of the coefficients of the correlation matrix rho_ij^Z that satisfy the resulting expression.","category":"page"},{"location":"Isoprobabilistic Transformations/NatafTransformation/#API","page":"Nataf Transformation","title":"API","text":"","category":"section"},{"location":"Isoprobabilistic Transformations/NatafTransformation/#Fortuna.NatafTransformation","page":"Nataf Transformation","title":"Fortuna.NatafTransformation","text":"NatafTransformation <: AbstractTransformation\n\nType used to perform Nataf Transformation.\n\nX::AbstractVector{<:Distribution{Univariate, Continuous}}: Random vector vecX\nρˣ::AbstractMatrix{<:Real}: Correlation matrix rho^X\nρᶻ::AbstractMatrix{<:Real}: Distorted correlation matrix rho^Z\nL::AbstractMatrix{<:Real}: Lower triangular matrix of the Cholesky decomposition of the distorted correlation matrix L\nL⁻¹::AbstractMatrix{<:Real}: Inverse of the lower triangular matrix of the Cholesky decomposition of the distorted correlation matrix L^-1\n\n\n\n\n\n","category":"type"},{"location":"Isoprobabilistic Transformations/NatafTransformation/#Fortuna.getdistortedcorrelation-Tuple{AbstractVector{<:Distribution{Univariate, Continuous}}, AbstractMatrix{<:Real}}","page":"Nataf Transformation","title":"Fortuna.getdistortedcorrelation","text":"getdistortedcorrelation(X::AbstractVector{<:Distributions.UnivariateDistribution}, ρˣ::AbstractMatrix{<:Real})\n\nFunction used to compute the distorted correlation matrix rho^Z.\n\n\n\n\n\n","category":"method"},{"location":"Isoprobabilistic Transformations/NatafTransformation/#Fortuna.transformsamples-Tuple{NatafTransformation, AbstractVector{<:Real}, Symbol}","page":"Nataf Transformation","title":"Fortuna.transformsamples","text":"transformsamples(TransformationObject::NatafTransformation, Samples::AbstractVector{<:Real}, TransformationDirection::Symbol)\n\nFunction used to transform samples from X- to U-space and vice versa. \nIf `TransformationDirection is:\n\n:X2U, then the function transforms samples vecx from X- to U-space.\n:U2X, then the function transforms samples vecu from U- to X-space.\n\n\n\n\n\n","category":"method"},{"location":"Isoprobabilistic Transformations/NatafTransformation/#Fortuna.getjacobian-Tuple{NatafTransformation, AbstractVector{<:Real}, Symbol}","page":"Nataf Transformation","title":"Fortuna.getjacobian","text":"getjacobian(TransformationObject::NatafTransformation, Samples::AbstractVector{<:Real}, TransformationDirection::Symbol)\n\nFunction used to compute the Jacobians of the transformations of samples from X- to U-space and vice versa. \nIf TransformationDirection is:\n\n:X2U, then the function returns the Jacobians of the transformations of samples vecx from X- to U-space.\n:U2X, then the function returns the Jacobians of the transformations of samples vecu from U- to X-space.\n\n\n\n\n\n","category":"method"},{"location":"Isoprobabilistic Transformations/NatafTransformation/#Distributions.pdf-Tuple{NatafTransformation, AbstractVector{<:Real}}","page":"Nataf Transformation","title":"Distributions.pdf","text":"pdf(TransformationObject::NatafTransformation, x::AbstractVector{<:Real})\n\nFunction used to compute the joint PDF in X-space.\n\n\n\n\n\n","category":"method"},{"location":"Random Variables/SampleRandomVariables/#Sampling-Random-Variables","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"","category":"section"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"Fortuna.jl package allows to easily generate samples of both uncorrelated and correlated random variables using rand() function using different sampling techniques. Current version of the package implements Inverse Transform Sampling (ITS) and Latin Hypercube Sampling (LHS) techniques.","category":"page"},{"location":"Random Variables/SampleRandomVariables/#Sampling-Random-Variables-2","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"","category":"section"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"To generate samples of a random variable:","category":"page"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"Generate a random variable (X).","category":"page"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"X = randomvariable(\"Gamma\", \"M\", [10, 1.5])\n\nnothing # hide","category":"page"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"Sample the generated random variable using a sampling technique of your choice.","category":"page"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"X_samples = rand(X, 10000, :LHS)\n\nnothing # hide","category":"page"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"<img src=\"../../assets/Theory-Sampling-1.png\" class=\"center\" style=\"max-height:350px; border-radius:2.5px;\"/>","category":"page"},{"location":"Random Variables/SampleRandomVariables/#Sampling-Random-Vectors-with-Uncorrelated-Marginals","page":"Sampling Random Variables","title":"Sampling Random Vectors with Uncorrelated Marginals","text":"","category":"section"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"To generate samples of a random vector with uncorrelated marginals:","category":"page"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"Generate random variables (X_1 and X_2).","category":"page"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"X_1 = randomvariable(\"Gamma\", \"M\", [10, 1.5])\nX_2 = randomvariable(\"Gamma\", \"M\", [15, 2.5])\n\nnothing #hide","category":"page"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"Define a random vector (X) with the generated random variables as marginals.","category":"page"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"X = [X_1, X_2]\n\nnothing # hide","category":"page"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"Sample the defined random vector using a sampling technique of your choice.","category":"page"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"X_samples = rand(X, 10000, :LHS)\n\nnothing # hide","category":"page"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"<img src=\"../../assets/Theory-Sampling-2.png\" class=\"center\" style=\"max-height:350px; border-radius:2.5px;\"/>","category":"page"},{"location":"Random Variables/SampleRandomVariables/#Sampling-Random-Vectors-with-Correlated-Marginals","page":"Sampling Random Variables","title":"Sampling Random Vectors with Correlated Marginals","text":"","category":"section"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"note: Note\nWhen sampling random vectors with correlated marginals, the sampling technique determines how samples are generated in the space of uncorrelated standard normal random variables (referred to as U-space). These generated samples are then transformed into the target space of correlated non-normal random variables (referred to as X-space). For more information see Nataf Transformation and Rosenblatt Transformation.","category":"page"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"To generate samples of a random vector with correlated marginals:","category":"page"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"Generate random variables (X_1 and X_2).","category":"page"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"X_1 = randomvariable(\"Gamma\", \"M\", [10, 1.5])\nX_2 = randomvariable(\"Gamma\", \"M\", [15, 2.5])\n\nnothing # hide","category":"page"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"Define a random vector (X) with the generated random variables as marginals.","category":"page"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"X = [X_1, X_2]\n\nnothing # hide","category":"page"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"Define a correlated matrix (ρˣ) for the defined random vector.","category":"page"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"ρ_X = [1 -0.75; -0.75 1]\n\nnothing # hide","category":"page"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"Define a transformation object that hold all information about the defined random vector.","category":"page"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"transformation_object = NatafTransformation(X, ρ_X)\n\nnothing # hide","category":"page"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"Sample the defined random vector using a sampling technique of your choice.","category":"page"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"X_samples, Z_samples, U_samples = rand(transformation_object, 10000, :LHS)\n\nnothing # hide","category":"page"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"<img src=\"../../assets/Theory-Sampling-3.png\" class=\"center\" style=\"max-height:350px; border-radius:2.5px;\"/>","category":"page"},{"location":"Random Variables/SampleRandomVariables/#API","page":"Sampling Random Variables","title":"API","text":"","category":"section"},{"location":"Random Variables/SampleRandomVariables/#Base.rand-Tuple{AbstractRNG, Distribution{Univariate, Continuous}, Int64, Symbol}","page":"Sampling Random Variables","title":"Base.rand","text":"rand(RNG::Distributions.AbstractRNG, RandomVariable::Distributions.UnivariateDistribution, NumSamples::Integer, SamplingTechnique::Symbol)\n\nFunction used to generate samples from an random variable. If SamplingTechnique is:\n\n:ITS samples are generated using Inverse Transform Sampling technique.\n:LHS samples are generated using Latin Hypercube Sampling technique.\n\n\n\n\n\n","category":"method"},{"location":"Random Variables/SampleRandomVariables/#Base.rand-Tuple{AbstractRNG, Vector{<:Distribution{Univariate, Continuous}}, Int64, Symbol}","page":"Sampling Random Variables","title":"Base.rand","text":"rand(RNG::Distributions.AbstractRNG, RandomVector::Vector{<:Distributions.UnivariateDistribution}, NumSamples::Integer, SamplingTechnique::Symbol)\n\nFunction used to generate samples from a random vector with uncorrelated marginals. If SamplingTechnique is:\n\n:ITS samples are generated using Inverse Transform Sampling technique.\n:LHS samples are generated using Latin Hypercube Sampling technique.\n\n\n\n\n\n","category":"method"},{"location":"Random Variables/SampleRandomVariables/#Base.rand-Tuple{AbstractRNG, NatafTransformation, Int64, Symbol}","page":"Sampling Random Variables","title":"Base.rand","text":"rand(RNG::Distributions.AbstractRNG, TransformationObject::NatafTransformation, NumSamples::Integer, SamplingTechnique::Symbol)\n\nFunction used to generate samples from a random vector with correlated marginals using Nataf Transformation object. If SamplingTechnique is:\n\n:ITS samples are generated using Inverse Transform Sampling technique.\n:LHS samples are generated using Latin Hypercube Sampling technique.\n\n\n\n\n\n","category":"method"},{"location":"Reliability Problems/SSM/#Subset-Simulation-Method","page":"Subset Simulation Method","title":"Subset Simulation Method","text":"","category":"section"},{"location":"Reliability Problems/SSM/#Overview","page":"Subset Simulation Method","title":"Overview","text":"","category":"section"},{"location":"Reliability Problems/SSM/","page":"Subset Simulation Method","title":"Subset Simulation Method","text":"The Subset Simulation method (SSM) is a robust simulation technique that transforms a rare event into a sequence of multiple intermediate failure events with larger probabilities and efficiently approximates the probability of the mentioned rare event. That is, the failure event Omega_f = vecX g(vecX) leq 0 is expressed as a union of M nested intermediate events Omega_f_1, dots, Omega_f_M, such that Omega_f_M subset dots subset Omega_f_1 and Omega_f = cap_i = 1^M Omega_f_i. The intermediate failure events are defined as Omega_f_i = vecX g(vecX) leq b_i, where b_1  dots  b_M = 0 are non-negative thresholds selected such that each conditional probability P(Omega_f_i + 1  Omega_f_i) equals a target conditional probability P_0.","category":"page"},{"location":"Reliability Problems/SSM/","page":"Subset Simulation Method","title":"Subset Simulation Method","text":"P_f = P(Omega_f) = P(cap_i = 1^M Omega_f_i) = P(Omega_f_1) prod_i = 1^M - 1 P(Omega_f_i + 1  Omega_f_i)","category":"page"},{"location":"Reliability Problems/SSM/","page":"Subset Simulation Method","title":"Subset Simulation Method","text":"The threshold for the first failure event b_1 is computed using the Monte Carlo simulations. The thresholds for the following intermediate failure events b_i are computed using the Monte Carlo Markov Chain samples generated from the conditional probability density functions f_vecX(vecx  Omega_f_i).","category":"page"},{"location":"Reliability Problems/SSM/","page":"Subset Simulation Method","title":"Subset Simulation Method","text":"Current implementation of the SSM follows Au and Beck (2001).","category":"page"},{"location":"Reliability Problems/SSM/#API","page":"Subset Simulation Method","title":"API","text":"","category":"section"},{"location":"Reliability Problems/SSM/#Fortuna.solve-Tuple{ReliabilityProblem, SSM}","page":"Subset Simulation Method","title":"Fortuna.solve","text":"solve(Problem::ReliabilityProblem, AnalysisMethod::SSM)\n\nFunction used to solve reliability problems using Subset Simulation Method (SSM).\n\n\n\n\n\n","category":"method"},{"location":"Reliability Problems/SSM/#Fortuna.SSM","page":"Subset Simulation Method","title":"Fortuna.SSM","text":"SSM <: AbstractReliabililyAnalysisMethod\n\nType used to perform reliability analysis using Subset Simulation Method (SSM).\n\nP₀::Real: Probability of failure for each subset P_0\nNumSamples::Integer: Number of samples generated within each subset N\nMaxNumSubsets::Integer: Maximum number of subsets M\n\n\n\n\n\n","category":"type"},{"location":"Reliability Problems/SSM/#Fortuna.SSMCache","page":"Subset Simulation Method","title":"Fortuna.SSMCache","text":"SSMCache\n\nType used to perform reliability analysis using Subset Simulation Method (SSM).\n\nXSamplesSubset::Vector{Matrix{Float64}}: Samples generated within each subset in X-space\nUSamplesSubset::Vector{Matrix{Float64}}: Samples generated within each subset in U-space\nCSubset::Vector{Float64}: Threshold for each subset C_i\nPoFSubset::Vector{Float64}: Probability of failure for each subset P_f_i\nPoF::Float64: Probability of failure P_f\nConvergance::Bool: Convergance status\n\n\n\n\n\n","category":"type"},{"location":"Reliability Problems/IS/#Importance-Sampling","page":"Importance Sampling","title":"Importance Sampling","text":"","category":"section"},{"location":"Reliability Problems/IS/#Overview","page":"Importance Sampling","title":"Overview","text":"","category":"section"},{"location":"Reliability Problems/IS/","page":"Importance Sampling","title":"Importance Sampling","text":"The Importance Sampling (IS) is a useful Monte Carlo method which allows to estimate the probabilities of rare failure events P_f for reliability problems with both simple and complex limit state functions g(vecX). The IS method is based on the following reformulation of the general analytical expression for the probability of failure P_f:","category":"page"},{"location":"Reliability Problems/IS/","page":"Importance Sampling","title":"Importance Sampling","text":"P_f = P(Omega_f) = int_Omega_f f_vecX(vecx) dvecx = int_mathbbR^n mathbbI(vecx) f_vecX(vecx) = int_mathbbR^n dfracmathbbI(vecx) f_vecX(vecx)q(vecx) q(vecx) dvecx = mathbbE_qleftdfracmathbbI(vecx) f_vecX(vecx)q(vecx)right","category":"page"},{"location":"Reliability Problems/IS/","page":"Importance Sampling","title":"Importance Sampling","text":"where f_vecX(vecx) is the target joint probability density function of the input random vector vecX, q(vecx) is the proposal probability density function, Omega_f = vecX g(vecX) leq 0 is the failure domain defined by the limit state function g(vecX), and mathbbI(vecx) is the indicator function given by:","category":"page"},{"location":"Reliability Problems/IS/","page":"Importance Sampling","title":"Importance Sampling","text":"mathbbI(vecx) = \nbegincases\n    1  textif  vecx in Omega_f \n    0  textotherwise\nendcases","category":"page"},{"location":"Reliability Problems/IS/","page":"Importance Sampling","title":"Importance Sampling","text":"Therefore, the probability of failure P_f is defined as the expectation of mathbbI(vecx) f_vecX(vecx)  q(vecx) evaluated with respect to the proposal probability density function q(vecx). If samples of the input random vector vecx are generated numerically from the proposal probability density function q(vecx), then the estimator of the probability of failure hatP_f is","category":"page"},{"location":"Reliability Problems/IS/","page":"Importance Sampling","title":"Importance Sampling","text":"hatP_f = dfrac1N sum_i = 1^N dfracmathbbI(vecx_i) f_vecX(vecx_i)q(vecx_i)","category":"page"},{"location":"Reliability Problems/IS/","page":"Importance Sampling","title":"Importance Sampling","text":"where N is the number of generated sampled. The estimator hatP_f is unbiased, i.e., it correctly predicts the true probability of failure, such that  mathbbE(hatP_f) = P_f.","category":"page"},{"location":"Reliability Problems/IS/","page":"Importance Sampling","title":"Importance Sampling","text":"If the proposal probability density function q(vecx) is chosen to be such that has large values in the failure domain Omega_f (important region), then it is possible to relatively accurately estimate small probability of failure P_f with a small number of samples N. The hard part is, of course, finding a \"good\" proposal probability density function q(vecx). Typically, it is recommended to use a multivariate normal distribution with uncorrelated marginals centered at the design point vecx^*, such that,","category":"page"},{"location":"Reliability Problems/IS/","page":"Importance Sampling","title":"Importance Sampling","text":"q sim N(vecM = vecx^* Sigma = sigma I)","category":"page"},{"location":"Reliability Problems/IS/#API","page":"Importance Sampling","title":"API","text":"","category":"section"},{"location":"Reliability Problems/IS/#Fortuna.solve-Tuple{ReliabilityProblem, IS}","page":"Importance Sampling","title":"Fortuna.solve","text":"solve(Problem::ReliabilityProblem, AnalysisMethod::IS; showprogressbar = false)\n\nFunction used to solve reliability problems using Importance Sampling (IS) method.\n\n\n\n\n\n","category":"method"},{"location":"Reliability Problems/IS/#Fortuna.IS","page":"Importance Sampling","title":"Fortuna.IS","text":"IS <: AbstractReliabililyAnalysisMethod\n\nType used to perform reliability analysis using Importance Sampling (IS) method.\n\n\n\n\n\n","category":"type"},{"location":"Reliability Problems/IS/#Fortuna.ISCache","page":"Importance Sampling","title":"Fortuna.ISCache","text":"ISCache\n\nType used to store results of reliability analysis performed using Importance Sampling (IS) method.\n\n\n\n\n\n","category":"type"},{"location":"Research/#Research","page":"Research","title":"Research","text":"","category":"section"},{"location":"Research/","page":"Research","title":"Research","text":"A comprehensive list of all academic publications that have used Fortuna.jl:","category":"page"},{"location":"Research/","page":"Research","title":"Research","text":"Akchurin, D.; Sabelli, R.; Ziemian, R. D. and Schafer, B. W. (2024). ASD and LRFD: Reliability Comparison for Designs Subjected to Wind Loads. Journal of Constructional Steel Research 213, 108327.\n\n\n\nDegtyarev, V. V.; Hicks, S. J.; Ferreira, F. P. and Tsavdaridis, K. D. (2024). Probabilistic Resistance Predictions of Laterally Restrained Cellular Steel Beams by Natural Gradient Boosting. Thin-Walled Structures 205, 112367. Accessed on Sep 18, 2024.\n\n\n\nDegtyarev, V. V.; Hicks, S. J.; Ferreira, F. P. and Tsavdaridis, K. D. (2025). Design Provision Assessment for the Resistance of Laterally Restrained Cellular Steel Beams. Journal of Constructional Steel Research 226, 109254. Accessed on Mar 3, 2025.\n\n\n\n","category":"page"},{"location":"Reliability Problems/ReliabilityProblems/#Reliability-Problems","page":"Reliability Problems","title":"Reliability Problems","text":"","category":"section"},{"location":"Reliability Problems/ReliabilityProblems/#Defining-Reliability-Problems","page":"Reliability Problems","title":"Defining Reliability Problems","text":"","category":"section"},{"location":"Reliability Problems/ReliabilityProblems/","page":"Reliability Problems","title":"Reliability Problems","text":"In general, 3 main \"items\" are always need to fully define a reliability problem and successfully solve it to find the associated probability of failure P_f and reliability index beta:","category":"page"},{"location":"Reliability Problems/ReliabilityProblems/","page":"Reliability Problems","title":"Reliability Problems","text":"Item Description\nvecX Random vector with correlated non-normal marginals\nrho^X Correlation matrix\ng(vecX) Limit state function","category":"page"},{"location":"Reliability Problems/ReliabilityProblems/","page":"Reliability Problems","title":"Reliability Problems","text":"Fortuna.jl package uses these 3 \"items\" to fully define reliability problems using a custom ReliabilityProblem() type as shown in the example below.","category":"page"},{"location":"Reliability Problems/ReliabilityProblems/","page":"Reliability Problems","title":"Reliability Problems","text":"# Define random vector:\nX_1 = randomvariable(\"Normal\", \"M\", [10, 2])\nX_2 = randomvariable(\"Normal\", \"M\", [20, 5])\nX   = [X_1, X_2]\n\n# Define correlation matrix:\nρ_X = [1 0.5; 0.5 1]\n\n# Define limit state function:\ng(x::Vector) = x[1] ^ 2 - 2 * x[2]\n\n# Define reliability problem:\nproblem = ReliabilityProblem(X, ρ_X, g)\n\nnothing # hide","category":"page"},{"location":"Reliability Problems/ReliabilityProblems/","page":"Reliability Problems","title":"Reliability Problems","text":"note: Note\nThe definition of the limit state function g(vecX) in Fortuna.jl package only pertains to its form (e.g., whether it is linear, square, exponential, etc. in each variable). The information about the random variables involved in the reliability problem is carried in the random vector vecX and its correlation matrix rho^X, that you use when defining a reliability problem using a custom ReliabilityProblem() type.","category":"page"},{"location":"Reliability Problems/ReliabilityProblems/#Solving-Reliability-Problems","page":"Reliability Problems","title":"Solving Reliability Problems","text":"","category":"section"},{"location":"Reliability Problems/ReliabilityProblems/","page":"Reliability Problems","title":"Reliability Problems","text":"After defining a reliability problem, Fortuna.jl allows to easily solve it using a wide suite of first- and second-order reliability methods using a single solve() function as shown in the example below.","category":"page"},{"location":"Reliability Problems/ReliabilityProblems/","page":"Reliability Problems","title":"Reliability Problems","text":"# Perform reliability analysis using improved Hasofer-Lind-Rackwitz-Fiessler (iHLRF) method:\nsolution = solve(problem, FORM(iHLRF()))\nprintln(\"β: $(solution.β)\")\nprintln(\"PoF: $(solution.PoF)\")","category":"page"},{"location":"Reliability Problems/ReliabilityProblems/","page":"Reliability Problems","title":"Reliability Problems","text":"Descriptions of all first- and second-order reliability methods implemented in Fortuna.jl can be found on First-Order Reliability Methods and Second-Order Reliability Methods pages.","category":"page"},{"location":"Reliability Problems/ReliabilityProblems/#API","page":"Reliability Problems","title":"API","text":"","category":"section"},{"location":"Reliability Problems/ReliabilityProblems/#Fortuna.ReliabilityProblem","page":"Reliability Problems","title":"Fortuna.ReliabilityProblem","text":"ReliabilityProblem <: AbstractReliabilityProblem\n\nType used to define reliability problems.\n\nX::AbstractVector{<:UnivariateDistribution}: Random vector vecX\nρˣ::AbstractMatrix{<:Real}: Correlation matrix rho^X\ng::Function: Limit state function g(vecX)\n\n\n\n\n\n","category":"type"},{"location":"SensitivityProblems/#Sensitivity-Problems","page":"Sensitivity Problems","title":"Sensitivity Problems","text":"","category":"section"},{"location":"SensitivityProblems/#Types-of-Sensitivity-Problems-in-Fortuna.jl","page":"Sensitivity Problems","title":"Types of Sensitivity Problems in Fortuna.jl","text":"","category":"section"},{"location":"SensitivityProblems/","page":"Sensitivity Problems","title":"Sensitivity Problems","text":"Fortuna.jl districts two types of sensitivity problems:","category":"page"},{"location":"SensitivityProblems/","page":"Sensitivity Problems","title":"Sensitivity Problems","text":"Type Description\nI Used to find sensitivities w.r.t. to the parameters vecTheta_g of the limit state function g(vecX vecTheta_g)\nII Used to find sensitivities w.r.t. to the parameters and/or moments vecTheta_f of the random vector vecX(vecTheta_f)","category":"page"},{"location":"SensitivityProblems/#Defining-and-Solving-Sensitivity-Problems-of-Type-I","page":"Sensitivity Problems","title":"Defining and Solving Sensitivity Problems of Type I","text":"","category":"section"},{"location":"SensitivityProblems/","page":"Sensitivity Problems","title":"Sensitivity Problems","text":"In general, 4 main \"items\" are always needed to fully define a sensitivity problem of type I and successfully solve it to find the associated sensitivity vectors of probability of failure vecnabla_vecTheta_g P_f and reliability index vecnabla_vecTheta_g beta w.r.t. to the parameters of the limit state function vecTheta_g:","category":"page"},{"location":"SensitivityProblems/","page":"Sensitivity Problems","title":"Sensitivity Problems","text":"Item Description\nvecX Random vector\nrho^X Correlation matrix\ng(vecX vecTheta_g) Limit state function parametrized in terms of its parameters\nvecTheta_g Parameters of the limit state function","category":"page"},{"location":"SensitivityProblems/","page":"Sensitivity Problems","title":"Sensitivity Problems","text":"Fortuna.jl package uses these 4 \"items\" to fully define sensitivity problems of type I using SensitivityProblem() type as shown in the example below.","category":"page"},{"location":"SensitivityProblems/","page":"Sensitivity Problems","title":"Sensitivity Problems","text":"# Define the random vector:\nM_1 = randomvariable(\"Normal\",  \"M\", [250,   250   * 0.3])\nM_2 = randomvariable(\"Normal\",  \"M\", [125,   125   * 0.3])\nP   = randomvariable(\"Gumbel\",  \"M\", [2500,  2500  * 0.2])\nY   = randomvariable(\"Weibull\", \"M\", [40000, 40000 * 0.1])\nX   = [M_1, M_2, P, Y]\n\n# Define the correlation matrix:\nρ_X = [\n    1.0 0.5 0.3 0.0\n    0.5 1.0 0.3 0.0\n    0.3 0.3 1.0 0.0\n    0.0 0.0 0.0 1.0]\n\n# Define the limit state function:\ng(x::Vector, θ::Vector) = 1 - x[1] / (θ[1] * x[4]) - x[2] / (θ[2] * x[4]) - (x[3] / (θ[3] * x[4])) ^ 2\n\n# Define parameters of the limit state function:\ns_1 = 0.030\ns_2 = 0.015\na   = 0.190\nΘ   = [s_1, s_2, a]\n\n# Define a sensitivity problem:\nproblem = SensitivityProblemTypeI(X, ρ_X, g, Θ)\n\nnothing # hide","category":"page"},{"location":"SensitivityProblems/","page":"Sensitivity Problems","title":"Sensitivity Problems","text":"After defining a sensitivity problem of type I, Fortuna.jl allows to easily perform sensitivity analysis using a single solve() function as shown in the example below.","category":"page"},{"location":"SensitivityProblems/","page":"Sensitivity Problems","title":"Sensitivity Problems","text":"# Perform the sensitivity analysis:\nsolution = solve(problem)\nprintln(\"∇β   = $(solution.∇β)\")\nprintln(\"∇PoF = $(solution.∇PoF)\")","category":"page"},{"location":"SensitivityProblems/#Defining-and-Solving-Sensitivity-Problems-of-Type-II","page":"Sensitivity Problems","title":"Defining and Solving Sensitivity Problems of Type II","text":"","category":"section"},{"location":"SensitivityProblems/","page":"Sensitivity Problems","title":"Sensitivity Problems","text":"Similar to sensitivity problem of type I, 4 main \"items\" are needed to fully define a sensitivity problem of type II and successfully solve it to find the associated sensitivity vectors of probability of failure vecnabla_vecTheta_f P_f and reliability index vecnabla_vecTheta_f beta w.r.t. to the parameters and/or moments of the random vector vecTheta_f:","category":"page"},{"location":"SensitivityProblems/","page":"Sensitivity Problems","title":"Sensitivity Problems","text":"Item Description\nvecX(vecTheta_f) Random vector with correlated non-normal marginals parameterized in terms of its parameters and/or moments\nrho^X Correlation matrix\ng(vecX) Limit state function\nvecTheta_f Parameters and/or moments of the random vector","category":"page"},{"location":"SensitivityProblems/","page":"Sensitivity Problems","title":"Sensitivity Problems","text":"Fortuna.jl package uses these 4 \"items\" to fully define sensitivity problems of type I using SensitivityProblem() type as shown in the example below.","category":"page"},{"location":"SensitivityProblems/","page":"Sensitivity Problems","title":"Sensitivity Problems","text":"# Define the random vector as a function of its parameters and moments:\nfunction X(Θ::Vector)\n    M_1 = randomvariable(\"Normal\",  \"M\", [Θ[1], Θ[2]])\n    M_2 = randomvariable(\"Normal\",  \"M\", [Θ[3], Θ[4]])\n    P   = randomvariable(\"Gumbel\",  \"M\", [Θ[5], Θ[6]])\n    Y   = randomvariable(\"Weibull\", \"M\", [Θ[7], Θ[8]])\n\n    return [M_1, M_2, P, Y]\nend\n\n# Define the correlation matrix:\nρ_X = [\n    1.0 0.5 0.3 0.0\n    0.5 1.0 0.3 0.0\n    0.3 0.3 1.0 0.0\n    0.0 0.0 0.0 1.0]\n\n# Define the parameters and moments of the random vector:\nΘ = [\n      250,   250 * 0.30,\n      125,   125 * 0.30,\n     2500,  2500 * 0.20,\n    40000, 40000 * 0.10]\n\n# Define the limit state function:\na   = 0.190\ns_1 = 0.030\ns_2 = 0.015\ng(x::Vector) = 1 - x[1] / (s_1 * x[4]) - x[2] / (s_2 * x[4]) - (x[3] / (a * x[4])) ^ 2\n\n# Define a sensitivity problem:\nproblem  = SensitivityProblemTypeII(X, ρ_X, g, Θ)\n\nnothing # hide","category":"page"},{"location":"SensitivityProblems/","page":"Sensitivity Problems","title":"Sensitivity Problems","text":"Similar to sensitivity problems of type I, sensitivity problems of type II are solved using the same solve() function as shown in the example below.","category":"page"},{"location":"SensitivityProblems/","page":"Sensitivity Problems","title":"Sensitivity Problems","text":"# Perform the sensitivity analysis:\nsolution = solve(problem)\nprintln(\"∇β   = $(solution.∇β)\")\nprintln(\"∇PoF = $(solution.∇PoF)\")","category":"page"},{"location":"SensitivityProblems/#API","page":"Sensitivity Problems","title":"API","text":"","category":"section"},{"location":"SensitivityProblems/#Fortuna.solve-Tuple{SensitivityProblemTypeI}","page":"Sensitivity Problems","title":"Fortuna.solve","text":"solve(Problem::SensitivityProblemTypeI; backend = AutoForwardDiff())\n\nFunction used to solve sensitivity problems of type I (sensitivities w.r.t. the parameters of the limit state function).\n\n\n\n\n\n","category":"method"},{"location":"SensitivityProblems/#Fortuna.solve-Tuple{SensitivityProblemTypeII}","page":"Sensitivity Problems","title":"Fortuna.solve","text":"solve(Problem::SensitivityProblemTypeII; backend = AutoForwardDiff())\n\nFunction used to solve sensitivity problems of type II (sensitivities w.r.t. the parameters of the random vector).\n\n\n\n\n\n","category":"method"},{"location":"SensitivityProblems/#Fortuna.SensitivityProblemTypeI","page":"Sensitivity Problems","title":"Fortuna.SensitivityProblemTypeI","text":"SensitivityProblemTypeI <: AbstractReliabilityProblem\n\nType used to define sensitivity problems of type I (sensitivities w.r.t. the parameters of the limit state function).\n\nX::AbstractVector{<:UnivariateDistribution}: Random vector vecX\nρˣ::AbstractMatrix{<:Real}: Correlation matrix rho^X\ng::Function: Limit state function g(vecX vecTheta)\nΘ::AbstractVector{<:Real}: Parameters of limit state function vecTheta\n\n\n\n\n\n","category":"type"},{"location":"SensitivityProblems/#Fortuna.SensitivityProblemTypeII","page":"Sensitivity Problems","title":"Fortuna.SensitivityProblemTypeII","text":"SensitivityProblemTypeII <: AbstractReliabilityProblem\n\nType used to define sensitivity problems of type II (sensitivities w.r.t. the parameters of the random vector).\n\nX::Function: Random vector vecX(vecTheta)\nρˣ::AbstractMatrix{<:Real}: Correlation matrix rho^X\ng::Function: Limit state function g(vecX)\nΘ::AbstractVector{<:Real}: Parameters of limit state function vecTheta\n\n\n\n\n\n","category":"type"},{"location":"SensitivityProblems/#Fortuna.SensitivityProblemCache","page":"Sensitivity Problems","title":"Fortuna.SensitivityProblemCache","text":"SensitivityProblemCache\n\nType used to store results of sensitivity analysis for problems of type I (sensitivities w.r.t. the parameters of the limit state function).\n\nFORMSolution::iHLRFCache: Results of reliability analysis performed using First-Order Reliability Method (FORM)\n∇β::Vector{Float64}: Sensivity vector of reliability index vecnabla_vecTheta beta\n∇PoF::Vector{Float64}: Sensivity vector of probability of failure vecnabla_vecTheta P_f\n\n\n\n\n\n","category":"type"},{"location":"Random Variables/DefineRandomVariables/#Defining-Random-Variables","page":"Defining Random Variables","title":"Defining Random Variables","text":"","category":"section"},{"location":"Random Variables/DefineRandomVariables/","page":"Defining Random Variables","title":"Defining Random Variables","text":"Fortuna.jl package builds its capacity to define random variables using randomvariable() wrapper function by utilizing the widely-adopted Distributions.jl package, enabling seamless integration with other probabilistic programming Julia packages such as Copulas.jl, Turing.jl and RxInfer.jl. However, unlike Distributions.jl package, Fortuna.jl package allows to define random variables not only using their parameters, but also using their moments, which often useful in the field of Structural and System Reliability Analysis.","category":"page"},{"location":"Random Variables/DefineRandomVariables/#Defining-Random-Variables-Using-Moments","page":"Defining Random Variables","title":"Defining Random Variables Using Moments","text":"","category":"section"},{"location":"Random Variables/DefineRandomVariables/","page":"Defining Random Variables","title":"Defining Random Variables","text":"To define a random variable using its moments, pass \"M\" as the second argument of randomvariable() function followed by the moments themselves:","category":"page"},{"location":"Random Variables/DefineRandomVariables/","page":"Defining Random Variables","title":"Defining Random Variables","text":"# Define a lognormally distributed random variable R with \n# mean (μ) of 15 and standard deviation (σ) of 10:\nR = randomvariable(\"LogNormal\", \"M\", [15, 10])\nprintln(\"μ: $(mean(R))\")\nprintln(\"σ: $(std(R))\")","category":"page"},{"location":"Random Variables/DefineRandomVariables/#Defining-Random-Variables-Using-Parameters","page":"Defining Random Variables","title":"Defining Random Variables Using Parameters","text":"","category":"section"},{"location":"Random Variables/DefineRandomVariables/","page":"Defining Random Variables","title":"Defining Random Variables","text":"To define a random variable using its parameters pass, \"P\" as the second argument of randomvariable() function followed by the parameters themselves:","category":"page"},{"location":"Random Variables/DefineRandomVariables/","page":"Defining Random Variables","title":"Defining Random Variables","text":"# Define a gamma-distributed random variable Q with \n# shape parameter (α) of 16 and scale parameter (θ) of 0.625:\nQ = randomvariable(\"Gamma\", \"P\", [16, 0.625])\nprintln(\"α: $(params(Q)[1])\")\nprintln(\"θ: $(params(Q)[2])\")","category":"page"},{"location":"Random Variables/DefineRandomVariables/#Supported-Random-Variables","page":"Defining Random Variables","title":"Supported Random Variables","text":"","category":"section"},{"location":"Random Variables/DefineRandomVariables/","page":"Defining Random Variables","title":"Defining Random Variables","text":"note: Note\nIf you want to define a random variable that is not supported by Fortuna.jl package, please raise an issue on the Github Issues page.","category":"page"},{"location":"Random Variables/DefineRandomVariables/","page":"Defining Random Variables","title":"Defining Random Variables","text":"Fortuna.jl package currently supports the following distributions:","category":"page"},{"location":"Random Variables/DefineRandomVariables/","page":"Defining Random Variables","title":"Defining Random Variables","text":"Exponential\nFrechet\nGamma\nGumbel\nLogNormal\nNormal\nPoisson\nUniform\nWeibull","category":"page"},{"location":"Random Variables/DefineRandomVariables/#API","page":"Defining Random Variables","title":"API","text":"","category":"section"},{"location":"Random Variables/DefineRandomVariables/#Fortuna.randomvariable-Tuple{AbstractString, AbstractString, Union{Real, AbstractVector{<:Real}}}","page":"Defining Random Variables","title":"Fortuna.randomvariable","text":"randomvariable(Distribution::AbstractString, DefineBy::AbstractString, Values::Union{Real, AbstractVector{<:Real}})\n\nFunction used to define random variables.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"Audentes Fortuna Iuvat","category":"page"},{"location":"#Description","page":"Home","title":"Description","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Fortuna.jl is a general-purpose Julia package for structural and system reliability analysis.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install Fortuna.jl package, type ] in Julia REPL to enter the built-in Julia package manager and execute the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add Fortuna","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you have used Fortuna.jl package for a scientific publication, please cite the following journal article on the package published in the Journal of Open Source Software:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{Fortuna.jl:Akchurin:2024, \n  title     = {Fortuna.jl: Structural and System Reliability Analysis in Julia},\n  author    = {Damir Akchurin},\n  year      = {2024},\n  publisher = {The Open Journal},\n  journal   = {Journal of Open Source Software},\n  volume    = {9},\n  number    = {100},\n  pages     = {6967},\n  doi       = {10.21105/joss.06967}, \n  url       = {https://doi.org/10.21105/joss.06967}\n}","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Fortuna.jl package is distributed under the MIT license. More information can be found in the LICENSE.md file.","category":"page"},{"location":"#Help-and-Support","page":"Home","title":"Help and Support","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For assistance with the package, please raise an issue on the GitHub Issues page. Please use the appropriate labels to indicate the specific functionality you are inquiring about. Alternatively, contact the author directly at AkchurinDA@gmail.com.","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The author thanks the academic and industrial partners of the Cold-Formed Steel Research Consortium’s “Reliability 2030” initiative for their financial support.","category":"page"},{"location":"Isoprobabilistic Transformations/RosenblattTransformation/","page":"Rosenblatt Transformation","title":"Rosenblatt Transformation","text":"warning: Warning\nThis feature is currently under development.","category":"page"},{"location":"Isoprobabilistic Transformations/RosenblattTransformation/#RosenblattTransformationPage","page":"Rosenblatt Transformation","title":"Rosenblatt Transformation","text":"","category":"section"},{"location":"Isoprobabilistic Transformations/RosenblattTransformation/#Overview","page":"Rosenblatt Transformation","title":"Overview","text":"","category":"section"},{"location":"Isoprobabilistic Transformations/RosenblattTransformation/","page":"Rosenblatt Transformation","title":"Rosenblatt Transformation","text":"The Rosenblatt Transformation is another widely utilized isoprobabilistic transformation in structural reliability analysis. Similar to the Nataf Transformation, its purpose is to transform random vectors with correlated non-normal marginals vecX into random vectors with uncorrelated standard normal marginals vecU. This transformation was first introduced by Murray Rosenblatt in 1952 (Rosenblatt, 1952).","category":"page"},{"location":"Isoprobabilistic Transformations/RosenblattTransformation/","page":"Rosenblatt Transformation","title":"Rosenblatt Transformation","text":"The Nataf Transformation vecU = T^R(vecX) is composed of two transformations: ","category":"page"},{"location":"Isoprobabilistic Transformations/RosenblattTransformation/","page":"Rosenblatt Transformation","title":"Rosenblatt Transformation","text":"vecU = T^R(vecX) = (T_2^R circ T_1^R)(vecX)","category":"page"},{"location":"Isoprobabilistic Transformations/RosenblattTransformation/","page":"Rosenblatt Transformation","title":"Rosenblatt Transformation","text":"The first transformation vecZ = T_1^R(vecX) transforms random vector with correlated non-normal marginal random variables vecX (with correlation matrix rho^X) into random vector with uncorrelated uniform marginal random variables vecZ.","category":"page"},{"location":"Isoprobabilistic Transformations/RosenblattTransformation/","page":"Rosenblatt Transformation","title":"Rosenblatt Transformation","text":"vecZ = T_1^R(vecX) = \n    beginbmatrix \n    F_X_1(X_1)  \n    F_X_2  X_1(X_2  X_1)  \n    vdots  \n    F_X_n  X_n - 1 dots X_1(X_n  X_n - 1 dots X_1) \nendbmatrix","category":"page"},{"location":"Isoprobabilistic Transformations/RosenblattTransformation/","page":"Rosenblatt Transformation","title":"Rosenblatt Transformation","text":"The second transformation vecU = T_2^R(vecZ) transforms random vector with uncorrelated uniform marginal random variables vecZ into random vector with uncorrelated standard normal marginal random variables vecU.","category":"page"},{"location":"Isoprobabilistic Transformations/RosenblattTransformation/","page":"Rosenblatt Transformation","title":"Rosenblatt Transformation","text":"vecU = T_2^R(vecZ) = beginbmatrix Phi^-1(Z_1)  vdots  Phi^-1(Z_n) endbmatrix","category":"page"},{"location":"Isoprobabilistic Transformations/RosenblattTransformation/#API","page":"Rosenblatt Transformation","title":"API","text":"","category":"section"},{"location":"Isoprobabilistic Transformations/RosenblattTransformation/#Fortuna.RosenblattTransformation","page":"Rosenblatt Transformation","title":"Fortuna.RosenblattTransformation","text":"RosenblattTransformation <: AbstractTransformation\n\nType used to perform Rosenblatt Transformation.\n\n\n\n\n\n","category":"type"},{"location":"Reliability Problems/SORM/#SORMPage","page":"Second-Order Reliability Methods","title":"Second-Order Reliability Methods","text":"","category":"section"},{"location":"Reliability Problems/SORM/","page":"Second-Order Reliability Methods","title":"Second-Order Reliability Methods","text":"The SORM is an improvement over the FORM by accounting for the curved nature of the failure boundary given by g(vecX) = 0 around the design point vecx^*; thus, providing a better approximation of the probability of failure P_f.","category":"page"},{"location":"Reliability Problems/SORM/#Curve-Fitting-Method","page":"Second-Order Reliability Methods","title":"Curve-Fitting Method","text":"","category":"section"},{"location":"Reliability Problems/SORM/","page":"Second-Order Reliability Methods","title":"Second-Order Reliability Methods","text":"The CF method fits a hyper-paraboloid surface with a vertex at the design point vecx^* and the principal curvatures matching the principal curvatures of the failure boundary given by g(vecX) = 0 at that point. The probabilities P_f of failure are estimated using Hohenbichler and Rackwitz (1988) and Breitung (1984) approximations of the exact solution provided by Tvedt (1990). The calculated probabilities of failure P_f are then used to estimate the generalized reliability indices beta, which account for the curved nature of the failure boundary given by g(vecX) = 0 around the design point vecx^*.","category":"page"},{"location":"Reliability Problems/SORM/#Point-Fitting-Method","page":"Second-Order Reliability Methods","title":"Point-Fitting Method","text":"","category":"section"},{"location":"Reliability Problems/SORM/","page":"Second-Order Reliability Methods","title":"Second-Order Reliability Methods","text":"The PF method fits a series of hyper-semiparaboloid surfaces with a vertex at the design point vecx^*. The principal curvatures of each surface are estimated using fitting points found at the intersections of a hyper-cylinder with axis coinciding with the design point vecu^* and the failure boundary given by g(vecU) = 0 in U-space. The PF method provides a better estimate of the probability of failure P_f than the CF method since it provides a better approximation of highly non-linear failure boundaries given by g(vecX) = 0 that are unsymmetrical about the design point vecx^*.","category":"page"},{"location":"Reliability Problems/SORM/","page":"Second-Order Reliability Methods","title":"Second-Order Reliability Methods","text":"note: Note\nA great description of both methods can be found in Der Kiureghian (2022).","category":"page"},{"location":"Reliability Problems/SORM/#API","page":"Second-Order Reliability Methods","title":"API","text":"","category":"section"},{"location":"Reliability Problems/SORM/#Fortuna.solve-Tuple{ReliabilityProblem, SORM}","page":"Second-Order Reliability Methods","title":"Fortuna.solve","text":"solve(Problem::ReliabilityProblem, AnalysisMethod::SORM;      FORMSolution::Union{Nothing, HLRFCache, iHLRFCache} = nothing,     FORMConfig::FORM = FORM(),      backend = AutoForwardDiff())\n\nFunction used to solve reliability problems using Second-Order Reliability Method (SORM).\n\n\n\n\n\n","category":"method"},{"location":"Reliability Problems/SORM/#Fortuna.SORM","page":"Second-Order Reliability Methods","title":"Fortuna.SORM","text":"SORM <: AbstractReliabililyAnalysisMethod\n\nType used to perform reliability analysis using Second-Order Reliability Method (SORM).\n\nSubmethod::Fortuna.SORMSubmethod\n\n\n\n\n\n","category":"type"},{"location":"Reliability Problems/SORM/#Fortuna.CF","page":"Second-Order Reliability Methods","title":"Fortuna.CF","text":"CF <: SORMSubmethod\n\nType used to perform reliability analysis using Curve-Fitting (CF) method.\n\nϵ::Real: Step size used to compute the Hessian at the design point in U-space\n\n\n\n\n\n","category":"type"},{"location":"Reliability Problems/SORM/#Fortuna.CFCache","page":"Second-Order Reliability Methods","title":"Fortuna.CFCache","text":"CFCache\n\nType used to perform reliability analysis using Point-Fitting (PF) method.\n\nFORMSolution::Union{HLRFCache, RFCache, iHLRFCache}: Results of reliability analysis performed using First-Order Reliability Method (FORM)\nβ₂::Vector{Union{Missing, Float64}}: Generalized reliability indices beta\nPoF₂::Vector{Union{Missing, Float64}}: Probabilities of failure P_f\nκ::Vector{Float64}: Principal curvatures kappa\n\n\n\n\n\n","category":"type"},{"location":"Reliability Problems/SORM/#Fortuna.PF","page":"Second-Order Reliability Methods","title":"Fortuna.PF","text":"PF <: SORMSubmethod\n\nType used to perform reliability analysis using Point-Fitting (PF) method.\n\n\n\n\n\n","category":"type"},{"location":"Reliability Problems/SORM/#Fortuna.PFCache","page":"Second-Order Reliability Methods","title":"Fortuna.PFCache","text":"PFCache\n\nType used to perform reliability analysis using Point-Fitting (PF) method.\n\nFORMSolution::iHLRFCache: Results of reliability analysis performed using First-Order Reliability Method (FORM)\nβ₂::Vector{Union{Missing, Float64}}: Generalized reliability index beta\nPoF₂::Vector{Union{Missing, Float64}}: Probabilities of failure P_f\nFittingPoints⁻::Matrix{Float64}: Fitting points on the negative side of the hyper-cylinder\nFittingPoints⁺::Matrix{Float64}: Fitting points on the positive side of the hyper-cylinder\nκ₁::Matrix{Float64}: Principal curvatures on the negative and positive sides\nκ₂::Matrix{Float64}: Principal curvatures of each hyper-semiparabola\n\n\n\n\n\n","category":"type"}]
}
