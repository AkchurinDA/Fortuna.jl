var documenterSearchIndex = {"docs":
[{"location":"Random Variables/GenerateRandomVariables/#Generating-Random-Variables","page":"Generating Random Variables","title":"Generating Random Variables","text":"","category":"section"},{"location":"Random Variables/GenerateRandomVariables/","page":"Generating Random Variables","title":"Generating Random Variables","text":"Fortuna.jl package builds its capacity to generate random variables using randomvariable() function by utilizing the widely-adopted Distributions.jl package, enabling seamless integration with other probabilistic programming Julia packages such as Turing.jl and RxInfer.jl. However, unlike Distributions.jl package, Fortuna.jl allows you to generate random variables not only using their parameters, but also using their moments, which often useful in the field of Structural and System Reliability Analysis.","category":"page"},{"location":"Random Variables/GenerateRandomVariables/","page":"Generating Random Variables","title":"Generating Random Variables","text":"using Fortuna","category":"page"},{"location":"Random Variables/GenerateRandomVariables/#Generating-Random-Variables-Using-Moments","page":"Generating Random Variables","title":"Generating Random Variables Using Moments","text":"","category":"section"},{"location":"Random Variables/GenerateRandomVariables/","page":"Generating Random Variables","title":"Generating Random Variables","text":"To generate a random variable using its moments use pass \"M\" as the second argument of randomvariable() function followed by the moments themselves. ","category":"page"},{"location":"Random Variables/GenerateRandomVariables/","page":"Generating Random Variables","title":"Generating Random Variables","text":"# Generate a lognormally distributed random variable R \n# with mean (μ) of 15 and standard deviation (σ) of 10:\nR = randomvariable(\"LogNormal\", \"M\", [15, 10])\nprintln(\"μ = $(mean(R))\")\nprintln(\"σ = $(std(R))\")","category":"page"},{"location":"Random Variables/GenerateRandomVariables/#Generating-Random-Variables-Using-Parameters","page":"Generating Random Variables","title":"Generating Random Variables Using Parameters","text":"","category":"section"},{"location":"Random Variables/GenerateRandomVariables/","page":"Generating Random Variables","title":"Generating Random Variables","text":"To generate a random variable using its parameters use pass \"P\" as the second argument of randomvariable() function followed by the parameters themselves. ","category":"page"},{"location":"Random Variables/GenerateRandomVariables/","page":"Generating Random Variables","title":"Generating Random Variables","text":"# Generate a gamma-distributed random variable Q \n# with shape parameter (α) of 16 and scale parameter (θ) of 0.625:\nQ = randomvariable(\"Gamma\", \"P\", [16, 0.625])\nprintln(\"α = $(params(Q)[1])\")\nprintln(\"θ = $(params(Q)[2])\")","category":"page"},{"location":"Random Variables/GenerateRandomVariables/#Supported-Random-Variables","page":"Generating Random Variables","title":"Supported Random Variables","text":"","category":"section"},{"location":"Random Variables/GenerateRandomVariables/","page":"Generating Random Variables","title":"Generating Random Variables","text":"note: Note\nIf you want to define a random variable that is not supported by Fortuna.jl package, please raise an issue on the Github Issues page.","category":"page"},{"location":"Random Variables/GenerateRandomVariables/","page":"Generating Random Variables","title":"Generating Random Variables","text":"Fortuna.jl package currently supports the following distributions:","category":"page"},{"location":"Random Variables/GenerateRandomVariables/","page":"Generating Random Variables","title":"Generating Random Variables","text":"Exponential\nGamma\nGumbel\nLogNormal\nNormal\nPoisson\nUniform\nWeibull","category":"page"},{"location":"Random Variables/GenerateRandomVariables/#API","page":"Generating Random Variables","title":"API","text":"","category":"section"},{"location":"Random Variables/GenerateRandomVariables/","page":"Generating Random Variables","title":"Generating Random Variables","text":"randomvariable(DistributionName::AbstractString, DefineBy::AbstractString, Values::Union{Real, AbstractVector{<:Real}})","category":"page"},{"location":"Random Variables/GenerateRandomVariables/#Fortuna.randomvariable-Tuple{AbstractString, AbstractString, Union{Real, AbstractVector{<:Real}}}","page":"Generating Random Variables","title":"Fortuna.randomvariable","text":"randomvariable(Distribution::AbstractString, DefineBy::AbstractString, Values::Union{Real, AbstractVector{<:Real}})\n\nFunction used to define random variables.\n\n\n\n\n\n","category":"method"},{"location":"Reliability Problems/MC/#Monte-Carlo-Simulations","page":"Monte Carlo Simulations","title":"Monte Carlo Simulations","text":"","category":"section"},{"location":"Reliability Problems/MC/#Overview","page":"Monte Carlo Simulations","title":"Overview","text":"","category":"section"},{"location":"Reliability Problems/MC/","page":"Monte Carlo Simulations","title":"Monte Carlo Simulations","text":"Using the brute force Monte Carlo simulations (MCS) is the simplest way to estimate the probability of failure P_f for reliability problems with both simple and complex limit state functions g(vecX). The brute force MCS relies on the following reformulation of the general analytical expression for the probability of failure P_f:","category":"page"},{"location":"Reliability Problems/MC/","page":"Monte Carlo Simulations","title":"Monte Carlo Simulations","text":"P_f = P(Omega_f) = int_Omega_f f_vecX(vecx) dvecx = int_mathbbR^n mathbbI(vecx) f_vecX(vecx) dvecx = mathbbE_fmathbbI(vecx)","category":"page"},{"location":"Reliability Problems/MC/","page":"Monte Carlo Simulations","title":"Monte Carlo Simulations","text":"where f_vecX(vecx) is the joint probability function of the input random vector vecX, Omega_f = vecX g(vecX) leq 0 is the failure domain defined by the limit state function g(vecX), and mathbbI(vecx) is the indicator function given by:","category":"page"},{"location":"Reliability Problems/MC/","page":"Monte Carlo Simulations","title":"Monte Carlo Simulations","text":"mathbbI(vecx) = \nbegincases\n    1  textif  vecx in Omega_f \n    0  textotherwise\nendcases","category":"page"},{"location":"Reliability Problems/MC/","page":"Monte Carlo Simulations","title":"Monte Carlo Simulations","text":"Therefore, the probability of failure P_f is defined as the expectation of the indicator function mathbbI(vecx). If samples of the input random vector vecx are generated numerically, then the estimator of the probability of failure hatP_f is","category":"page"},{"location":"Reliability Problems/MC/","page":"Monte Carlo Simulations","title":"Monte Carlo Simulations","text":"hatP_f = dfrac1N sum_i = 1^N mathbbI(vecx_i)","category":"page"},{"location":"Reliability Problems/MC/","page":"Monte Carlo Simulations","title":"Monte Carlo Simulations","text":"where N is the number of generated sampled. The estimator hatP_f is unbiased, i.e., it correctly predicts the true probability of failure, such that  mathbbE(hatP_f) = P_f. The main drawback of using the MCS is that is becomes prohibitively expensive to use if the true probability is too small, e.g., P_f leq 10^-3, given that the variance of the estimator is inversely proportional to the number of generated samples, such that,","category":"page"},{"location":"Reliability Problems/MC/","page":"Monte Carlo Simulations","title":"Monte Carlo Simulations","text":"textVar(hatP_f) = frac1N P_f (1 - P_f)","category":"page"},{"location":"Reliability Problems/MC/","page":"Monte Carlo Simulations","title":"Monte Carlo Simulations","text":"tip: Tip\nFor typical structural reliability problems with true probabilities of failure P_f of approx 10^-3, it is recommended to use N = 10^6 samples to get the coefficient of variation of the estimator V_P_f of approx 010.<img src=\"../../RecommendedNumSamples.svg\" class=\"center\" style=\"height:350px; border-radius:5px;\"/>","category":"page"},{"location":"Reliability Problems/MC/#API","page":"Monte Carlo Simulations","title":"API","text":"","category":"section"},{"location":"Reliability Problems/MC/","page":"Monte Carlo Simulations","title":"Monte Carlo Simulations","text":"MC\nMCCache\nsolve(Problem::ReliabilityProblem, AnalysisMethod::MC)","category":"page"},{"location":"Reliability Problems/MC/#Fortuna.MC","page":"Monte Carlo Simulations","title":"Fortuna.MC","text":"struct MC <: AbstractReliabililyAnalysisMethod\n\nType used to perform reliability analysis using Monte Carlo simulations.\n\nNumSamples::Integer: Number of samples N\nSamplingTechnique::AbstractSamplingTechnique: Sampling technique\n\n\n\n\n\n","category":"type"},{"location":"Reliability Problems/MC/#Fortuna.MCCache","page":"Monte Carlo Simulations","title":"Fortuna.MCCache","text":"struct MCCache\n\nType used to store results of reliability analysis performed using Monte Carlo simulations.\n\nSamples::Matrix{Float64}: Generated samples\nPoF::Float64: Probability of failure P_f\n\n\n\n\n\n","category":"type"},{"location":"Reliability Problems/MC/#Fortuna.solve-Tuple{ReliabilityProblem, MC}","page":"Monte Carlo Simulations","title":"Fortuna.solve","text":"solve(Problem::ReliabilityProblem, AnalysisMethod::MC)\n\nFunction used to solve reliability analysis using Monte Carlo simulations.\n\n\n\n\n\n","category":"method"},{"location":"Examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"using Fortuna\nusing Random\nRandom.seed!(123)","category":"page"},{"location":"Examples/#Isoprobabilistic-Transformation","page":"Examples","title":"Isoprobabilistic Transformation","text":"","category":"section"},{"location":"Examples/#Nataf-Transformation","page":"Examples","title":"Nataf Transformation","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"# Generate random vector:\nX₁  = randomvariable(\"Gamma\", \"M\", [10, 1.5])\nX₂  = randomvariable(\"Gumbel\", \"M\", [15, 2.5])\nX   = [X₁, X₂]\n\n# Define a correlation matrix:\nρˣ = [1 0.90; 0.90 1]\n\n# Perform Nataf Transformation:\nNatafObject = NatafTransformation(X, ρˣ)\n\n# Generate 1000 samples of random vector in X-, Z-, and U-spaces:\nXSamples, USamples, ZSamples = rand(NatafObject, 1000, ITS())\n\nnothing # hide","category":"page"},{"location":"Examples/","page":"Examples","title":"Examples","text":"<img src=\"../assets/NatafTransformation.svg\" class=\"center\" style=\"border-radius:5px;\"/>","category":"page"},{"location":"Examples/#Monte-Carlo-Simulations","page":"Examples","title":"Monte Carlo Simulations","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"# Generate random vector:\nM₁  = randomvariable(\"Normal\", \"M\", [250, 250 * 0.3])\nM₂  = randomvariable(\"Normal\", \"M\", [125, 125 * 0.3])\nP   = randomvariable(\"Gumbel\", \"M\", [2500, 2500 * 0.2])\nY   = randomvariable(\"Weibull\", \"M\", [40000, 40000 * 0.1])\nX   = [M₁, M₂, P, Y]\n\n# Define correlation matrix:\nρˣ = [1 0.5 0.3 0; 0.5 1 0.3 0; 0.3 0.3 1 0; 0 0 0 1]\n\n# Define limit state function:\na       = 0.190\ns₁      = 0.030\ns₂      = 0.015\ng(x)    = 1 - x[1] / (s₁ * x[4]) - x[2] / (s₂ * x[4]) - (x[3] / (a * x[4])) ^ 2\n\n# Define reliability problem:\nProblem = ReliabilityProblem(X, ρˣ, g)\n\n# Perform reliability analysis using Monte Carlo simulations:\nSolution = solve(Problem, MC())\nprintln(\"MC:\")\nprintln(\"PoF: $(Solution.PoF)\")","category":"page"},{"location":"Examples/#First-Order-Reliability-Methods","page":"Examples","title":"First-Order Reliability Methods","text":"","category":"section"},{"location":"Examples/#Mean-Centered-First-Order-Second-Moment-Method","page":"Examples","title":"Mean-Centered First-Order Second-Moment Method","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"# Generate random vector:\nX₁  = randomvariable(\"Normal\", \"M\", [10, 2])\nX₂  = randomvariable(\"Normal\", \"M\", [20, 5])\nX   = [X₁, X₂]\n\n# Define correlation matrix:\nρˣ = [1 0.5; 0.5 1]\n\n# Define two equivalent limit state functions:\ng₁(x) = x[1] ^ 2 - 2 * x[2]\ng₂(x) = 1 - 2 * x[2] / x[1] ^ 2\n\n# Define reliability problems:\nProblem₁ = ReliabilityProblem(X, ρˣ, g₁)\nProblem₂ = ReliabilityProblem(X, ρˣ, g₂)\n\n# Perform reliability analysis using Mean-Centered First-Order Second-Moment (MCFOSM) method:\nSolution₁ = solve(Problem₁, FORM(MCFOSM()))\nSolution₂ = solve(Problem₂, FORM(MCFOSM()))\nprintln(\"MCFOSM:\")\nprintln(\"β from g₁: $(Solution₁.β)\")\nprintln(\"β from g₂: $(Solution₂.β)\")","category":"page"},{"location":"Examples/#Improved-Hasofer-Lind-Rackwitz-Fiessler-Method","page":"Examples","title":"Improved Hasofer-Lind-Rackwitz-Fiessler Method","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"# Generate random vector:\nX₁  = randomvariable(\"Normal\", \"M\", [10, 2])\nX₂  = randomvariable(\"Normal\", \"M\", [20, 5])\nX   = [X₁, X₂]\n\n# Define correlation matrix:\nρˣ = [1 0.5; 0.5 1]\n\n# Define two equivalent limit state functions:\ng₁(x) = x[1] ^ 2 - 2 * x[2]\ng₂(x) = 1 - 2 * x[2] / x[1] ^ 2\n\n# Define reliability problems:\nProblem₁ = ReliabilityProblem(X, ρˣ, g₁)\nProblem₂ = ReliabilityProblem(X, ρˣ, g₂)\n\n# Perform reliability analysis using improved Hasofer-Lind-Rackwitz-Fiessler (iHLRF) method:\nSolution₁ = solve(Problem₁, FORM(iHLRF()))\nSolution₂ = solve(Problem₂, FORM(iHLRF()))\nprintln(\"FORM:\")\nprintln(\"β from g₁: $(Solution₁.β)\")\nprintln(\"β from g₂: $(Solution₂.β)\")","category":"page"},{"location":"Examples/#Second-Order-Reliability-Methods","page":"Examples","title":"Second-Order Reliability Methods","text":"","category":"section"},{"location":"Examples/#Curve-Fitting-Method","page":"Examples","title":"Curve-Fitting Method","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"# Generate random vector:\nM₁  = randomvariable(\"Normal\", \"M\", [250, 250 * 0.3])\nM₂  = randomvariable(\"Normal\", \"M\", [125, 125 * 0.3])\nP   = randomvariable(\"Gumbel\", \"M\", [2500, 2500 * 0.2])\nY   = randomvariable(\"Weibull\", \"M\", [40000, 40000 * 0.1])\nX   = [M₁, M₂, P, Y]\n\n# Define correlation matrix:\nρˣ = [1 0.5 0.3 0; 0.5 1 0.3 0; 0.3 0.3 1 0; 0 0 0 1]\n\n# Define limit state function:\na       = 0.190\ns₁      = 0.030\ns₂      = 0.015\ng(x)    = 1 - x[1] / (s₁ * x[4]) - x[2] / (s₂ * x[4]) - (x[3] / (a * x[4])) ^ 2\n\n# Define reliability problem:\nProblem = ReliabilityProblem(X, ρˣ, g)\n\n# Perform reliability analysis using Curve-Fitting (CF) method:\nSolution = solve(Problem, SORM(CF()))\nprintln(\"SORM:\")\nprintln(\"β from FORM:       $(Solution.FORMSolution.β)\")\nprintln(\"β from SORM:       $(Solution.β₂[1]) (Hohenbichler and Rackwitz)\")\nprintln(\"β from SORM:       $(Solution.β₂[2]) (Breitung)\")\nprintln(\"PoF from FORM:     $(Solution.FORMSolution.PoF)\")\nprintln(\"PoF from SORM:     $(Solution.PoF₂[1]) (Hohenbichler and Rackwitz)\")\nprintln(\"PoF from SORM:     $(Solution.PoF₂[2]) (Breitung)\")","category":"page"},{"location":"Examples/#Point-Fitting-Method","page":"Examples","title":"Point-Fitting Method","text":"","category":"section"},{"location":"Examples/","page":"Examples","title":"Examples","text":"# Generate random vector:\nM₁  = randomvariable(\"Normal\", \"M\", [250, 250 * 0.3])\nM₂  = randomvariable(\"Normal\", \"M\", [125, 125 * 0.3])\nP   = randomvariable(\"Gumbel\", \"M\", [2500, 2500 * 0.2])\nY   = randomvariable(\"Weibull\", \"M\", [40000, 40000 * 0.1])\nX   = [M₁, M₂, P, Y]\n\n# Define correlation matrix:\nρˣ = [1 0.5 0.3 0; 0.5 1 0.3 0; 0.3 0.3 1 0; 0 0 0 1]\n\n# Define limit state function:\na       = 0.190\ns₁      = 0.030\ns₂      = 0.015\ng(x)    = 1 - x[1] / (s₁ * x[4]) - x[2] / (s₂ * x[4]) - (x[3] / (a * x[4])) ^ 2\n\n# Define reliability problem:\nProblem = ReliabilityProblem(X, ρˣ, g)\n\n# Perform reliability analysis using Point-Fitting (PF) method:\nSolution = solve(Problem, SORM(PF()))\nprintln(\"SORM:\")\nprintln(\"β from FORM:       $(Solution.FORMSolution.β)\")\nprintln(\"β from SORM:       $(Solution.β₂[1]) (Hohenbichler and Rackwitz)\")\nprintln(\"β from SORM:       $(Solution.β₂[2]) (Breitung)\")\nprintln(\"PoF from FORM:     $(Solution.FORMSolution.PoF)\")\nprintln(\"PoF from SORM:     $(Solution.PoF₂[1]) (Hohenbichler and Rackwitz)\")\nprintln(\"PoF from SORM:     $(Solution.PoF₂[2]) (Breitung)\")","category":"page"},{"location":"InverseReliabilityProblems/","page":"Inverse Reliability Problems","title":"Inverse Reliability Problems","text":"warning: Warning\nThis feature is currently under development.","category":"page"},{"location":"InverseReliabilityProblems/#Inverse-Reliability-Problems","page":"Inverse Reliability Problems","title":"Inverse Reliability Problems","text":"","category":"section"},{"location":"References/#References","page":"References","title":"References","text":"","category":"section"},{"location":"References/","page":"References","title":"References","text":"Breitung, K. (1984). Asymptotic Approximations for Multinormal Integrals. Journal of Engineering Mechanics 110, 357–366.\n\n\n\nHohenbichler, M. and Rackwitz, R. (1988). Improvement Of Second‐Order Reliability Estimates by Importance Sampling. Journal of Engineering Mechanics 114, 2195–2199.\n\n\n\nNataf, A. (1962). Détermination des Distribution dont les Marges sont Données. Comptes Rendus de l'Académie des Sciences 225, 42–43.\n\n\n\nRosenblatt, M. (1952). Remarks on a Multivariate Transformation. The Annals of Mathematical Statistics 23, 470–472.\n\n\n\nTvedt, L. (1990). Distribution of Quadratic Forms in Normal Space—Application to Structural Reliability. Journal of Engineering Mechanics 116, 1183–1197.\n\n\n\n","category":"page"},{"location":"Reliability Problems/FORM/#FORMPage","page":"First-Order Reliability Methods","title":"First-Order Reliability Methods","text":"","category":"section"},{"location":"Reliability Problems/FORM/#Mean-Centered-First-Order-Second-Moment-Method","page":"First-Order Reliability Methods","title":"Mean-Centered First-Order Second-Moment Method","text":"","category":"section"},{"location":"Reliability Problems/FORM/","page":"First-Order Reliability Methods","title":"First-Order Reliability Methods","text":"The MCFOSM method is the simplest and least computationally expensive type of reliability method. It utilizes the first-order Taylor expansion of the limit state function g(vecX) at the mean values and the first two moments of the marginal random variables involved in the reliability problem to evaluate the reliability index. However, despite the fact that it is simple and does not require the complete knowledge of the random variables involved in the reliability problem, the MCFOSM method faces an issue known as the invariance problem. This problem arises because the resulting reliability index beta is dependent on the formulation of the limit state function g(vecX). In other words, two equivalent limit state functions with the same failure boundaries produce two different reliability indices; thus, the use of MCFOSM method is not recommended.","category":"page"},{"location":"Reliability Problems/FORM/#Rackwitz-Fiessler-Method","page":"First-Order Reliability Methods","title":"Rackwitz-Fiessler Method","text":"","category":"section"},{"location":"Reliability Problems/FORM/","page":"First-Order Reliability Methods","title":"First-Order Reliability Methods","text":"warning: Warning\nThis feature is currently under development.","category":"page"},{"location":"Reliability Problems/FORM/#Plain-and-Improved-Hasofer-Lind-Rackwitz-Fiessler-Method","page":"First-Order Reliability Methods","title":"Plain and Improved Hasofer-Lind-Rackwitz-Fiessler Method","text":"","category":"section"},{"location":"Reliability Problems/FORM/","page":"First-Order Reliability Methods","title":"First-Order Reliability Methods","text":"The HLRF method overcomes the invariance problem faced by the MCFOSM method by using the first-order Taylor expansion of the limit state function at a point known as the design point vecx^* that lies on the failure boundary given by g(vecX) = 0. Since the design point is not known a priori, the HLRF method is inherently an iterative method. Fortuna.jl implements two versions of HLRF method: plain HLRF method where the step size in the negative gradient descent is always set to unity and improved HLRF (iHLRF) method where the step size is determined using a line search algorithm.","category":"page"},{"location":"Reliability Problems/FORM/#API","page":"First-Order Reliability Methods","title":"API","text":"","category":"section"},{"location":"Reliability Problems/FORM/","page":"First-Order Reliability Methods","title":"First-Order Reliability Methods","text":"FORM\nsolve(Problem::ReliabilityProblem, AnalysisMethod::FORM)","category":"page"},{"location":"Reliability Problems/FORM/#Fortuna.FORM","page":"First-Order Reliability Methods","title":"Fortuna.FORM","text":"struct FORM <: AbstractReliabililyAnalysisMethod\n\nType used to perform reliability analysis using First-Order Reliability Method (FORM).\n\nSubmethod::Fortuna.FORMSubmethod\n\n\n\n\n\n","category":"type"},{"location":"Reliability Problems/FORM/#Fortuna.solve-Tuple{ReliabilityProblem, FORM}","page":"First-Order Reliability Methods","title":"Fortuna.solve","text":"solve(Problem::ReliabilityProblem, AnalysisMethod::FORM)\n\nFunction used to solve reliability analysis using First-Order Reliability Method (FORM).\n\n\n\n\n\n","category":"method"},{"location":"Isoprobabilistic Transformations/NatafTransformation/#Nataf-Transformation","page":"Nataf Transformation","title":"Nataf Transformation","text":"","category":"section"},{"location":"Isoprobabilistic Transformations/NatafTransformation/#Overview","page":"Nataf Transformation","title":"Overview","text":"","category":"section"},{"location":"Isoprobabilistic Transformations/NatafTransformation/","page":"Nataf Transformation","title":"Nataf Transformation","text":"The Nataf Transformation is a widely utilized isoprobabilistic transformation in structural reliability analysis. Its purpose is to transform random vectors with correlated non-normal marginals vecX into random vectors with uncorrelated standard normal marginals vecU. André Nataf introduced this transformation in 1962 (Nataf, 1962).","category":"page"},{"location":"Isoprobabilistic Transformations/NatafTransformation/","page":"Nataf Transformation","title":"Nataf Transformation","text":"The Nataf Transformation vecU = T^N(vecX) is composed of two transformations: ","category":"page"},{"location":"Isoprobabilistic Transformations/NatafTransformation/","page":"Nataf Transformation","title":"Nataf Transformation","text":"vecU = T^N(vecX) = (T_2^N circ T_1^N)(vecX)","category":"page"},{"location":"Isoprobabilistic Transformations/NatafTransformation/","page":"Nataf Transformation","title":"Nataf Transformation","text":"The first transformation vecZ = T_1^N(vecX) transforms random vector with correlated non-normal marginals vecX (with correlation matrix rho^X) into random vector with correlated standard normal marginals vecZ (with correlation matrix rho^Z). Here, Phi^-1(cdot) is the inverse of the cumulative density function of a standard normal random variable and F_X_i(cdot) is the cumulative density function of a marginalX_i.","category":"page"},{"location":"Isoprobabilistic Transformations/NatafTransformation/","page":"Nataf Transformation","title":"Nataf Transformation","text":"vecZ = T_1^N(vecX) = beginbmatrix Phi^-1(F_X_1(X_1))  vdots  Phi^-1(F_X_n(X_n)) endbmatrix ","category":"page"},{"location":"Isoprobabilistic Transformations/NatafTransformation/","page":"Nataf Transformation","title":"Nataf Transformation","text":"The second transformation vecU = T_2^N(vecZ) transforms random vector with correlated standard normal marginals vecZ into random vector with uncorrelated standard normal marginals vecU. Here, the matrix Gamma is used to decorrelate the standard normal marginals of random vector vecZ and can be chosen as any square-root matrix of the correlation matrix rho^Z. Fortuna.jl uses the Cholesky factor of the inverse of the correlation matrix (rho^Z)^-1 as the matrix Gamma.","category":"page"},{"location":"Isoprobabilistic Transformations/NatafTransformation/","page":"Nataf Transformation","title":"Nataf Transformation","text":"vecU = T_2^N(vecZ) = Gamma vecZ","category":"page"},{"location":"Isoprobabilistic Transformations/NatafTransformation/","page":"Nataf Transformation","title":"Nataf Transformation","text":"The first transformation vecZ = T_1^N(vecX) causes so-called correlation distortion. The correlation distortion causes the correlation coefficient between two standard normal marginals Z_i and Z_j, denoted by rho_ij^Z, to distort and differ from the original correlation coefficient between the corresponding non-normal marginals X_i and X_j, denoted by rho_ij^X, such that rho_ij^X neq rho_ij^Z. The relationship between the components of the correlation matrices rho_ij^X and rho_ij^X is given by","category":"page"},{"location":"Isoprobabilistic Transformations/NatafTransformation/","page":"Nataf Transformation","title":"Nataf Transformation","text":"rho_ij^X = dfrac1sigma_X_i sigma_X_j int_-infty^infty int_-infty^infty (F_X_i^-1(Phi(z_i)) - mu_X_i) (F_X_j^-1(Phi(z_j)) - mu_X_j) phi_2(z_i z_j rho_ij^Z) dz_i dz_j","category":"page"},{"location":"Isoprobabilistic Transformations/NatafTransformation/","page":"Nataf Transformation","title":"Nataf Transformation","text":"where phi_2(cdot) is the bivariate standard normal probability density function. Generally, this integral cannot be inverted analytically to solve for the coefficients of the correlation matrix rho^Z. In order to compute these coefficients, Fortuna.jl package (1) employs a two-dimensions Gauss-Legendre quadrature implemented in FastGaussQuadrature.jl package to expand the integral into  and (2) utilizes NonlinearSolve.jl package to find values of the coefficients of the correlation matrix rho^Z that satisfy the resulting expression.","category":"page"},{"location":"Isoprobabilistic Transformations/NatafTransformation/#API","page":"Nataf Transformation","title":"API","text":"","category":"section"},{"location":"Isoprobabilistic Transformations/NatafTransformation/","page":"Nataf Transformation","title":"Nataf Transformation","text":"NatafTransformation\ngetdistortedcorrelation(X::AbstractVector{<:Distributions.UnivariateDistribution}, ρˣ::AbstractMatrix{<:Real})\ntransformsamples(TransformationObject::NatafTransformation, Samples::AbstractVector{<:Real}, TransformationDirection::AbstractString)\ngetjacobian(TransformationObject::NatafTransformation, Samples::AbstractVector{<:Real}, TransformationDirection::AbstractString)\npdf(TransformationObject::NatafTransformation, x::AbstractVector{<:Real})","category":"page"},{"location":"Isoprobabilistic Transformations/NatafTransformation/#Fortuna.NatafTransformation","page":"Nataf Transformation","title":"Fortuna.NatafTransformation","text":"mutable struct NatafTransformation <: AbstractTransformation\n\nType used to perform Nataf Transformation.\n\nX::AbstractVector{<:Distributions.UnivariateDistribution}: Random vector vecX\nρˣ::AbstractMatrix{<:Real}: Correlation matrix rho^X\nρᶻ::AbstractMatrix{Float64}: Distorted correlation matrix rho^Z\nL::AbstractMatrix{Float64}: Lower triangular matrix of the Cholesky decomposition of the distorted correlation matrix L\nL⁻¹::AbstractMatrix{Float64}: Inverse of the lower triangular matrix of the Cholesky decomposition of the distorted correlation matrix L^-1\n\n\n\n\n\n","category":"type"},{"location":"Isoprobabilistic Transformations/NatafTransformation/#Fortuna.getdistortedcorrelation-Tuple{AbstractVector{<:Distributions.UnivariateDistribution}, AbstractMatrix{<:Real}}","page":"Nataf Transformation","title":"Fortuna.getdistortedcorrelation","text":"getdistortedcorrelation(X::AbstractVector{<:Distributions.UnivariateDistribution}, ρˣ::AbstractMatrix{<:Real})\n\nFunction used to compute the distorted correlation matrix rho^Z.\n\n\n\n\n\n","category":"method"},{"location":"Isoprobabilistic Transformations/NatafTransformation/#Fortuna.transformsamples-Tuple{NatafTransformation, AbstractVector{<:Real}, AbstractString}","page":"Nataf Transformation","title":"Fortuna.transformsamples","text":"transformsamples(TransformationObject::NatafTransformation, Samples::AbstractVector{<:Real}, TransformationDirection::AbstractString)\n\nFunction used to transform samples from X- to U-space and vice versa. \nIf `TransformationDirection is:\n\n\"X2U\", then the function transforms samples vecx from X- to U-space.\n\"U2X\", then the function transforms samples vecu from U- to X-space.\n\n\n\n\n\n","category":"method"},{"location":"Isoprobabilistic Transformations/NatafTransformation/#Fortuna.getjacobian-Tuple{NatafTransformation, AbstractVector{<:Real}, AbstractString}","page":"Nataf Transformation","title":"Fortuna.getjacobian","text":"getjacobian(TransformationObject::NatafTransformation, Samples::AbstractVector{<:Real}, TransformationDirection::AbstractString)\n\nFunction used to compute the Jacobians of the transformations of samples from X- to U-space and vice versa. \nIf TransformationDirection is:\n\n\"X2U\", then the function returns the Jacobians of the transformations of samples vecx from X- to U-space.\n\"U2X\", then the function returns the Jacobians of the transformations of samples vecu from U- to X-space.\n\n\n\n\n\n","category":"method"},{"location":"Isoprobabilistic Transformations/NatafTransformation/#Distributions.pdf-Tuple{NatafTransformation, AbstractVector{<:Real}}","page":"Nataf Transformation","title":"Distributions.pdf","text":"pdf(TransformationObject::NatafTransformation, x::AbstractVector{<:Real})\n\nFunction used to compute the joint PDF in X-space.\n\n\n\n\n\n","category":"method"},{"location":"Random Variables/SampleRandomVariables/#Sampling-Random-Variables","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"","category":"section"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"Fortuna.jl package allows to easily generate samples of both uncorrelated and correlated random variables using rand() function using different sampling techniques. Current version of the package implements Inverse Transform Sampling (ITS) and Latin Hypercube Sampling (LHS) techniques.","category":"page"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"using Fortuna\nusing Random\nRandom.seed!(1)","category":"page"},{"location":"Random Variables/SampleRandomVariables/#Sampling-Random-Variables-2","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"","category":"section"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"To generate samples of a random variable:","category":"page"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"Generate a random variable (X).","category":"page"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"X = randomvariable(\"Gamma\", \"M\", [10, 1.5])\n\nnothing # hide","category":"page"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"Sample the generated random variable using a sampling technique of your choice.","category":"page"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"XSamples = rand(X, 10000, LHS())\n\nnothing # hide","category":"page"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"<img src=\"../../assets/SampleRandomVariable.svg\" class=\"center\" style=\"max-height:400px; border-radius:2.5px;\"/>","category":"page"},{"location":"Random Variables/SampleRandomVariables/#Sampling-Random-Vectors-with-Uncorrelated-Marginals","page":"Sampling Random Variables","title":"Sampling Random Vectors with Uncorrelated Marginals","text":"","category":"section"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"To generate samples of a random vector with uncorrelated marginals:","category":"page"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"Generate random variables (X₁ and X₂).","category":"page"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"X₁ = randomvariable(\"Gamma\", \"M\", [10, 1.5])\nX₂ = randomvariable(\"Gamma\", \"M\", [15, 2.5])\n\nnothing #hide","category":"page"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"Define a random vector (X) with the generated random variables as marginals.","category":"page"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"X = [X₁, X₂]\n\nnothing # hide","category":"page"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"Sample the defined random vector using a sampling technique of your choice.","category":"page"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"XSamples = rand(X, 10000, LHS())\n\nnothing # hide","category":"page"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"<img src=\"../../assets/SampleUncorrelatedRandomVector.svg\" class=\"center\" style=\"max-height:400px; border-radius:2.5px;\"/>","category":"page"},{"location":"Random Variables/SampleRandomVariables/#Sampling-Random-Vectors-with-Correlated-Marginals","page":"Sampling Random Variables","title":"Sampling Random Vectors with Correlated Marginals","text":"","category":"section"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"To generate samples of a random vector with correlated marginals:","category":"page"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"Generate random variables (X₁ and X₂).","category":"page"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"X₁ = randomvariable(\"Gamma\", \"M\", [10, 1.5])\nX₂ = randomvariable(\"Gamma\", \"M\", [15, 2.5])\n\nnothing # hide","category":"page"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"Define a random vector (X) with the generated random variables as marginals.","category":"page"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"X = [X₁, X₂]\n\nnothing # hide","category":"page"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"Define a correlated matrix (ρˣ) for the defined random vector.","category":"page"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"ρˣ = [1 -0.75; -0.75 1]\n\nnothing # hide","category":"page"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"Define a transformation object that hold all information about the defined random vector.","category":"page"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"TransformationObject = NatafTransformation(X, ρˣ)\n\nnothing # hide","category":"page"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"Sample the defined random vector using a sampling technique of your choice.","category":"page"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"XSamples, ZSamples, USamples = rand(TransformationObject, 10000, LHS())\n\nnothing # hide","category":"page"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"<img src=\"../../assets/SampleCorrelatedRandomVector.svg\" class=\"center\" style=\"max-height:400px; border-radius:2.5px;\"/>","category":"page"},{"location":"Random Variables/SampleRandomVariables/#API","page":"Sampling Random Variables","title":"API","text":"","category":"section"},{"location":"Random Variables/SampleRandomVariables/","page":"Sampling Random Variables","title":"Sampling Random Variables","text":"ITS\nLHS\nrand(RNG::Distributions.AbstractRNG, RandomVariable::Distributions.UnivariateDistribution, NumSamples::Int, SamplingTechnique::AbstractSamplingTechnique)\nrand(RNG::Distributions.AbstractRNG, RandomVector::Vector{<:Distributions.UnivariateDistribution}, NumSamples::Int, SamplingTechnique::AbstractSamplingTechnique)\nrand(RNG::Distributions.AbstractRNG, TransformationObject::NatafTransformation, NumSamples::Int, SamplingTechnique::AbstractSamplingTechnique)","category":"page"},{"location":"Random Variables/SampleRandomVariables/#Fortuna.ITS","page":"Sampling Random Variables","title":"Fortuna.ITS","text":"struct ITS <: AbstractSamplingTechnique\n\nType used to perform the Inverse Transform Sampling.\n\n\n\n\n\n","category":"type"},{"location":"Random Variables/SampleRandomVariables/#Fortuna.LHS","page":"Sampling Random Variables","title":"Fortuna.LHS","text":"struct LHS <: AbstractSamplingTechnique\n\nType used to perform the Latin Hypercube Sampling.\n\n\n\n\n\n","category":"type"},{"location":"Random Variables/SampleRandomVariables/#Base.rand-Tuple{Random.AbstractRNG, Distributions.UnivariateDistribution, Int64, AbstractSamplingTechnique}","page":"Sampling Random Variables","title":"Base.rand","text":"rand(RNG::Distributions.AbstractRNG, RandomVariable::Distributions.UnivariateDistribution, NumSamples::Int, SamplingTechnique::AbstractSamplingTechnique)\n\nFunction used to generate samples from an random variable. If SamplingTechnique is:\n\nITS() samples are generated using Inverse Transform Sampling technique.\nLHS() samples are generated using Latin Hypercube Sampling technique.\n\n\n\n\n\n","category":"method"},{"location":"Random Variables/SampleRandomVariables/#Base.rand-Tuple{Random.AbstractRNG, Vector{<:Distributions.UnivariateDistribution}, Int64, AbstractSamplingTechnique}","page":"Sampling Random Variables","title":"Base.rand","text":"rand(RNG::Distributions.AbstractRNG, RandomVector::Vector{<:Distributions.UnivariateDistribution}, NumSamples::Int, SamplingTechnique::AbstractSamplingTechnique)\n\nFunction used to generate samples from a random vector with uncorrelated marginals. If SamplingTechnique is:\n\nITS() samples are generated using Inverse Transform Sampling technique.\nLHS() samples are generated using Latin Hypercube Sampling technique.\n\n\n\n\n\n","category":"method"},{"location":"Random Variables/SampleRandomVariables/#Base.rand-Tuple{Random.AbstractRNG, NatafTransformation, Int64, AbstractSamplingTechnique}","page":"Sampling Random Variables","title":"Base.rand","text":"rand(RNG::Distributions.AbstractRNG, TransformationObject::NatafTransformation, NumSamples::Int, SamplingTechnique::AbstractSamplingTechnique)\n\nFunction used to generate samples from a random vector with correlated marginals using Nataf Transformation object. If SamplingTechnique is:\n\nITS() samples are generated using Inverse Transform Sampling technique.\nLHS() samples are generated using Latin Hypercube Sampling technique.\n\n\n\n\n\n","category":"method"},{"location":"Reliability Problems/SSM/","page":"Subset Simulation Method","title":"Subset Simulation Method","text":"warning: Warning\nThis feature is experimental and not well-tested.","category":"page"},{"location":"Reliability Problems/SSM/#Subset-Simulation-Method","page":"Subset Simulation Method","title":"Subset Simulation Method","text":"","category":"section"},{"location":"Reliability Problems/SSM/#Overview","page":"Subset Simulation Method","title":"Overview","text":"","category":"section"},{"location":"Reliability Problems/SSM/","page":"Subset Simulation Method","title":"Subset Simulation Method","text":"The Subset Simulation method (SSM) is a robust simulation technique that transforms a rare event into a sequence of multiple intermediate failure events with larger probabilities and efficiently approximates the probability of the mentioned rare event. That is, the failure event Omega_f = vecX g(vecX) leq 0 is expressed as a union of M nested intermediate events Omega_f_1, dots, Omega_f_M, such that Omega_f_M subset dots subset Omega_f_1 and Omega_f = cap_i = 1^M Omega_f_i. The intermediate failure events are defined as Omega_f_i = vecX g(vecX) leq b_i, where b_1  dots  b_M = 0 are non-negative thresholds selected such that each conditional probability P(Omega_f_i + 1  Omega_f_i) equals a target conditional probability P_0.","category":"page"},{"location":"Reliability Problems/SSM/","page":"Subset Simulation Method","title":"Subset Simulation Method","text":"P_f = P(Omega_f) = P(cap_i = 1^M Omega_f_i) = P(Omega_f_1) prod_i = 1^M - 1 P(Omega_f_i + 1  Omega_f_i)","category":"page"},{"location":"Reliability Problems/SSM/","page":"Subset Simulation Method","title":"Subset Simulation Method","text":"The threshold for the first failure event b_1 is computed using the Monte Carlo simulations. The thresholds for the following intermediate failure events b_i are computed using the Monte Carlo Markov Chain samples generated from the conditional probability density functions f_vecX(vecx  Omega_f_i).","category":"page"},{"location":"Reliability Problems/SSM/#API","page":"Subset Simulation Method","title":"API","text":"","category":"section"},{"location":"Reliability Problems/IS/#Importance-Sampling","page":"Importance Sampling","title":"Importance Sampling","text":"","category":"section"},{"location":"Reliability Problems/IS/#Overview","page":"Importance Sampling","title":"Overview","text":"","category":"section"},{"location":"Reliability Problems/IS/","page":"Importance Sampling","title":"Importance Sampling","text":"The Importance Sampling (IS) is a useful Monte Carlo method which allows to estimate the probabilities of rare failure events P_f for reliability problems with both simple and complex limit state functions g(vecX). The IS method is based on the following reformulation of the general analytical expression for the probability of failure P_f:","category":"page"},{"location":"Reliability Problems/IS/","page":"Importance Sampling","title":"Importance Sampling","text":"P_f = P(Omega_f) = int_Omega_f f_vecX(vecx) dvecx = int_mathbbR^n mathbbI(vecx) f_vecX(vecx) = int_mathbbR^n dfracmathbbI(vecx) f_vecX(vecx)q(vecx) q(vecx) dvecx = mathbbE_qleftdfracmathbbI(vecx) f_vecX(vecx)q(vecx)right","category":"page"},{"location":"Reliability Problems/IS/","page":"Importance Sampling","title":"Importance Sampling","text":"where f_vecX(vecx) is the target joint probability density function of the input random vector vecX, q(vecx) is the proposal probability density function, Omega_f = vecX g(vecX) leq 0 is the failure domain defined by the limit state function g(vecX), and mathbbI(vecx) is the indicator function given by:","category":"page"},{"location":"Reliability Problems/IS/","page":"Importance Sampling","title":"Importance Sampling","text":"mathbbI(vecx) = \nbegincases\n    1  textif  vecx in Omega_f \n    0  textotherwise\nendcases","category":"page"},{"location":"Reliability Problems/IS/","page":"Importance Sampling","title":"Importance Sampling","text":"Therefore, the probability of failure P_f is defined as the expectation of mathbbI(vecx) f_vecX(vecx)  q(vecx) evaluated with respect to the proposal probability density function q(vecx). If samples of the input random vector vecx are generated numerically from the proposal probability density function q(vecx), then the estimator of the probability of failure hatP_f is","category":"page"},{"location":"Reliability Problems/IS/","page":"Importance Sampling","title":"Importance Sampling","text":"hatP_f = dfrac1N sum_i = 1^N dfracmathbbI(vecx_i) f_vecX(vecx_i)q(vecx_i)","category":"page"},{"location":"Reliability Problems/IS/","page":"Importance Sampling","title":"Importance Sampling","text":"where N is the number of generated sampled. The estimator hatP_f is unbiased, i.e., it correctly predicts the true probability of failure, such that  mathbbE(hatP_f) = P_f.","category":"page"},{"location":"Reliability Problems/IS/","page":"Importance Sampling","title":"Importance Sampling","text":"If the proposal probability density function q(vecx) is chosen to be such that has large values in the failure domain Omega_f (important region), then it is possible to relatively accurately estimate small probability of failure P_f with a small number of samples N. The hard part is, of course, finding a \"good\" proposal probability density function q(vecx). Typically, it is recommended to use a multivariate normal distribution with uncorrelated marginals centered at the design point vecx^*, such that,","category":"page"},{"location":"Reliability Problems/IS/","page":"Importance Sampling","title":"Importance Sampling","text":"q sim N(vecM = vecx^* Sigma = sigma I)","category":"page"},{"location":"Reliability Problems/IS/#API","page":"Importance Sampling","title":"API","text":"","category":"section"},{"location":"Reliability Problems/IS/","page":"Importance Sampling","title":"Importance Sampling","text":"IS\nISCache\nsolve(Problem::ReliabilityProblem, AnalysisMethod::IS)","category":"page"},{"location":"Reliability Problems/IS/#Fortuna.IS","page":"Importance Sampling","title":"Fortuna.IS","text":"struct IS <: AbstractReliabililyAnalysisMethod\n\nType used to perform reliability analysis using Importance Sampling method.\n\n\n\n\n\n","category":"type"},{"location":"Reliability Problems/IS/#Fortuna.ISCache","page":"Importance Sampling","title":"Fortuna.ISCache","text":"struct ISCache\n\nType used to store results of reliability analysis performed using Importance Sampling method.\n\n\n\n\n\n","category":"type"},{"location":"Reliability Problems/IS/#Fortuna.solve-Tuple{ReliabilityProblem, IS}","page":"Importance Sampling","title":"Fortuna.solve","text":"solve(Problem::ReliabilityProblem, AnalysisMethod::IS)\n\nFunction used to solve reliability analysis using Importance Sampling method.\n\n\n\n\n\n","category":"method"},{"location":"Showcases/#Showcases","page":"Showcases","title":"Showcases","text":"","category":"section"},{"location":"Showcases/","page":"Showcases","title":"Showcases","text":"A comprehensive list of all academic publications that have used Fortuna.jl:","category":"page"},{"location":"Showcases/","page":"Showcases","title":"Showcases","text":"Akchurin, D.; Sabelli, R.; Ziemian, R. D. and Schafer, B. W. (2024). ASD and LRFD: Reliability Comparison for Designs Subjected to Wind Loads. Journal of Constructional Steel Research 213, 108327.\n\n\n\n","category":"page"},{"location":"Reliability Problems/ReliabilityProblems/#Defining-Reliability-Problems","page":"Reliability Problems","title":"Defining Reliability Problems","text":"","category":"section"},{"location":"Reliability Problems/ReliabilityProblems/#Overview","page":"Reliability Problems","title":"Overview","text":"","category":"section"},{"location":"Reliability Problems/ReliabilityProblems/","page":"Reliability Problems","title":"Reliability Problems","text":"In generally, 3 main \"items\" are always need to fully define a reliability problem and successfully analyze it to find the associated probability of failure P_f and reliability index beta:","category":"page"},{"location":"Reliability Problems/ReliabilityProblems/","page":"Reliability Problems","title":"Reliability Problems","text":"vecX - Random vector with correlated non-normal marginals\nrho^X - Correlation matrix\ng(vecX) - Limit state function","category":"page"},{"location":"Reliability Problems/ReliabilityProblems/","page":"Reliability Problems","title":"Reliability Problems","text":"Fortuna.jl package uses these 3 \"items\" to fully define reliability problems using a custom ReliabilityProblem() type as shown in the example below.","category":"page"},{"location":"Reliability Problems/ReliabilityProblems/","page":"Reliability Problems","title":"Reliability Problems","text":"using Fortuna","category":"page"},{"location":"Reliability Problems/ReliabilityProblems/","page":"Reliability Problems","title":"Reliability Problems","text":"# Generate a random vector X with correlated marginal random variables X₁ and X₂:\nX₁  = randomvariable(\"Normal\", \"M\", [10, 2])\nX₂  = randomvariable(\"Normal\", \"M\", [20, 5])\nX   = [X₁, X₂]\n\n# Define a correlation matrix for the random vector X:\nρˣ = [1 0.5; 0.5 1]\n\n# Define a limit state function:\ng(x) = x[1] ^ 2 - 2 * x[2]\n\n# Define a reliability problem using the provided information:\nProblem = ReliabilityProblem(X, ρˣ, g)\n\nnothing # hide","category":"page"},{"location":"Reliability Problems/ReliabilityProblems/","page":"Reliability Problems","title":"Reliability Problems","text":"note: Note\nThe definition of the limit state function g(vecX) in Fortuna.jl package only pertains to its form (e.g., whether it is linear, square, exponential, etc. in each variable). The information about the random variables involved in the reliability problem is carried in the random vector vecX and its correlation matrix rho^X, that you use when defining a reliability problem using a custom ReliabilityProblem() type.","category":"page"},{"location":"Reliability Problems/ReliabilityProblems/#Analyzing-Reliability-Problems","page":"Reliability Problems","title":"Analyzing Reliability Problems","text":"","category":"section"},{"location":"Reliability Problems/ReliabilityProblems/","page":"Reliability Problems","title":"Reliability Problems","text":"After defining the reliability problem, Fortuna.jl allows to easily solve it using a whole suite of First- and Second-Order Reliability Methods through a single analyze() function as shown in the example below.","category":"page"},{"location":"Reliability Problems/ReliabilityProblems/","page":"Reliability Problems","title":"Reliability Problems","text":"# Solve the reliability problem using an imporved Hasofer-Lind-Rackwitz-Fiessler method:\nSolution = solve(Problem, FORM(iHLRF()))\nprintln(\"PoF    = $(Solution.PoF)\")\nprintln(\"β      = $(Solution.β)\")","category":"page"},{"location":"Reliability Problems/ReliabilityProblems/","page":"Reliability Problems","title":"Reliability Problems","text":"Descriptions of all First- and Second-Order Reliability Methods implemented in Fortuna.jl can be found on First-Order Reliability Methods and Second-Order Reliability Methods pages.","category":"page"},{"location":"Reliability Problems/ReliabilityProblems/#API","page":"Reliability Problems","title":"API","text":"","category":"section"},{"location":"Reliability Problems/ReliabilityProblems/","page":"Reliability Problems","title":"Reliability Problems","text":"ReliabilityProblem","category":"page"},{"location":"Reliability Problems/ReliabilityProblems/#Fortuna.ReliabilityProblem","page":"Reliability Problems","title":"Fortuna.ReliabilityProblem","text":"mutable struct ReliabilityProblem <: AbstractReliabilityProblem\n\nType used to define reliability problems.\n\n\n\n\n\n","category":"type"},{"location":"SensitivityProblems/#Sensitivity-Analysis","page":"Sensitivity Problems","title":"Sensitivity Analysis","text":"","category":"section"},{"location":"SensitivityProblems/#Overview","page":"Sensitivity Problems","title":"Overview","text":"","category":"section"},{"location":"SensitivityProblems/","page":"Sensitivity Problems","title":"Sensitivity Problems","text":"nabla_vectheta_g beta = dfracnabla_vectheta_g g(vecx^* vectheta_g)nabla_vecu G(vecu^* vectheta_g)","category":"page"},{"location":"SensitivityProblems/","page":"Sensitivity Problems","title":"Sensitivity Problems","text":"nabla_vectheta_g P_f = -phi(beta) nabla_vectheta_g beta","category":"page"},{"location":"SensitivityProblems/#API","page":"Sensitivity Problems","title":"API","text":"","category":"section"},{"location":"Reliability Problems/SORM/#SORMPage","page":"Second-Order Reliability Methods","title":"Second-Order Reliability Methods","text":"","category":"section"},{"location":"Reliability Problems/SORM/","page":"Second-Order Reliability Methods","title":"Second-Order Reliability Methods","text":"The SORM is an improvement over the FORM by accounting for the curved nature of the failure boundary given by g(vecX) = 0 around the design point vecx^*; thus, providing a better approximation of the probability of failure P_f.","category":"page"},{"location":"Reliability Problems/SORM/#Curve-Fitting-Method","page":"Second-Order Reliability Methods","title":"Curve-Fitting Method","text":"","category":"section"},{"location":"Reliability Problems/SORM/","page":"Second-Order Reliability Methods","title":"Second-Order Reliability Methods","text":"Fortuna.jl package implements the CF method that fits a hyper-paraboloid surface with a vertex at the design point vecx^* and the principal curvatures matching the principal curvatures of the failure boundary  given by g(vecX) = 0 at that point. The probabilities P_f of failure are estimated using Hohenbichler and Rackwitz (1988) and Breitung (1984) approximations of the exact solution provided by Tvedt (1990). The calculated probabilities of failure P_f are then used to estimate the generalized reliability indices beta, which account for the curved nature of the failure boundary given by g(vecX) = 0 around the design point vecx^*.","category":"page"},{"location":"Reliability Problems/SORM/#Point-Fitting-Method","page":"Second-Order Reliability Methods","title":"Point-Fitting Method","text":"","category":"section"},{"location":"Reliability Problems/SORM/","page":"Second-Order Reliability Methods","title":"Second-Order Reliability Methods","text":"warning: Warning\nThis feature is currently under development.","category":"page"},{"location":"Reliability Problems/SORM/#API","page":"Second-Order Reliability Methods","title":"API","text":"","category":"section"},{"location":"Reliability Problems/SORM/","page":"Second-Order Reliability Methods","title":"Second-Order Reliability Methods","text":"SORM\nsolve(Problem::ReliabilityProblem, AnalysisMethod::SORM)","category":"page"},{"location":"Reliability Problems/SORM/#Fortuna.SORM","page":"Second-Order Reliability Methods","title":"Fortuna.SORM","text":"struct SORM <: AbstractReliabililyAnalysisMethod\n\nType used to perform reliability analysis using Second-Order Reliability Method (SORM).\n\nSubmethod::Fortuna.SORMSubmethod\n\n\n\n\n\n","category":"type"},{"location":"Reliability Problems/SORM/#Fortuna.solve-Tuple{ReliabilityProblem, SORM}","page":"Second-Order Reliability Methods","title":"Fortuna.solve","text":"solve(Problem::ReliabilityProblem, AnalysisMethod::SORM)\n\nFunction used to solve reliability analysis using Second-Order Reliability Method (SORM).\n\n\n\n\n\n","category":"method"},{"location":"#Fortuna","page":"Home","title":"Fortuna","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Audentes Fortuna Iuvat","category":"page"},{"location":"#Description","page":"Home","title":"Description","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Fortuna.jl is a general-purpose Julia package for structural and system reliability analysis.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install Fortuna.jl package, type ] in Julia REPL to enter the built-in Julia package manager and execute the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add Fortuna","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Fortuna.jl package is distributed under the MIT license. More information can be found in the LICENSE.md file.","category":"page"},{"location":"#Help-and-Support","page":"Home","title":"Help and Support","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For assistance with the package, please raise an issue on the Github Issues page. Please use the appropriate labels to indicate the specific functionality you are inquiring about. Alternatively, contact the author directly at AkchurinDA@gmail.com.","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The author thanks the academic and industrial partners of the Cold-Formed Steel Research Consortium’s “Reliability 2030” initiative for their financial support.","category":"page"},{"location":"Isoprobabilistic Transformations/RosenblattTransformation/","page":"Rosenblatt Transformation","title":"Rosenblatt Transformation","text":"warning: Warning\nThis feature is currently under development.","category":"page"},{"location":"Isoprobabilistic Transformations/RosenblattTransformation/#Rosenblatt-Transformation","page":"Rosenblatt Transformation","title":"Rosenblatt Transformation","text":"","category":"section"},{"location":"Isoprobabilistic Transformations/RosenblattTransformation/#Overview","page":"Rosenblatt Transformation","title":"Overview","text":"","category":"section"},{"location":"Isoprobabilistic Transformations/RosenblattTransformation/","page":"Rosenblatt Transformation","title":"Rosenblatt Transformation","text":"The Rosenblatt Transformation is another widely utilized isoprobabilistic transformation in structural reliability analysis. Similar to the Nataf Transformation, its purpose is to transform random vectors with correlated non-normal marginal random variables vecX into random vectors with uncorrelated standard normal marginal random variables vecU. Murray Rosenblatt introduced this transformation in 1952 (Rosenblatt, 1952).","category":"page"},{"location":"Isoprobabilistic Transformations/RosenblattTransformation/","page":"Rosenblatt Transformation","title":"Rosenblatt Transformation","text":"The Nataf Transformation vecU = T^R(vecX) is composed of two transformations: ","category":"page"},{"location":"Isoprobabilistic Transformations/RosenblattTransformation/","page":"Rosenblatt Transformation","title":"Rosenblatt Transformation","text":"vecU = T^R(vecX) = (T_2^R circ T_1^R)(vecX)","category":"page"},{"location":"Isoprobabilistic Transformations/RosenblattTransformation/","page":"Rosenblatt Transformation","title":"Rosenblatt Transformation","text":"The first transformation vecZ = T_1^R(vecX) transforms random vector with correlated non-normal marginal random variables vecX (with correlation matrix rho^X) into random vector with uncorrelated uniform marginal random variables vecZ.","category":"page"},{"location":"Isoprobabilistic Transformations/RosenblattTransformation/","page":"Rosenblatt Transformation","title":"Rosenblatt Transformation","text":"vecZ = T_1^R(vecX) = beginbmatrix F_X_1(X_1)  vdots  F_X_n  X_n - 1 dots X_1(X_n  X_n - 1 dots X_1) endbmatrix","category":"page"},{"location":"Isoprobabilistic Transformations/RosenblattTransformation/","page":"Rosenblatt Transformation","title":"Rosenblatt Transformation","text":"The second transformation vecU = T_2^R(vecZ) transforms random vector with uncorrelated uniform marginal random variables vecZ into random vector with uncorrelated standard normal marginal random variables vecU.","category":"page"},{"location":"Isoprobabilistic Transformations/RosenblattTransformation/","page":"Rosenblatt Transformation","title":"Rosenblatt Transformation","text":"vecU = T_2^R(vecZ) = beginbmatrix Phi^-1(Z_1)  vdots  Phi^-1(Z_n) endbmatrix","category":"page"},{"location":"Isoprobabilistic Transformations/RosenblattTransformation/#API","page":"Rosenblatt Transformation","title":"API","text":"","category":"section"},{"location":"Isoprobabilistic Transformations/RosenblattTransformation/","page":"Rosenblatt Transformation","title":"Rosenblatt Transformation","text":"RosenblattTransformation","category":"page"},{"location":"Isoprobabilistic Transformations/RosenblattTransformation/#Fortuna.RosenblattTransformation","page":"Rosenblatt Transformation","title":"Fortuna.RosenblattTransformation","text":"mutable struct RosenblattTransformation <: AbstractTransformation\n\nType used to perform Rosenblatt Transformation.\n\n\n\n\n\n","category":"type"}]
}
